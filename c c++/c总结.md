1. 编译就是把C语言代码翻译成机器码；
2. 链接就是一个“打包”的过程，它将所有的目标文件以及系统组件组合成一个可执行文件。
3. printf, scanf, fprintf, fscanf, sprintf, sscanf;区分和使用；
4. 指令 ：对数据操作的最小单位；
5. 写代码一点要注释（面试的时候）；
6. 全局变量有定义与声明的区别，局部变量声明与定义都是定义；
7. 声明可以有多个，定义只能有一个；
8. printf 不会进行数据类型的转换；
9. 赋值的时候会自动转换（有符号的转换成无符号的，整数转换成浮点数）（return 和 函数参数  也会进行自动类型转换）  程序员可以进行强制转换
10. 常量是一旦赋值就不能改变，可以用#define和const,const比宏有好处，定义的时候同时就可以指定类型，但c语言的const是可以通过指针间接修改，是不安全的
11. a%b = a - (int)(a / b)*b
12. 一个二进制叫一个位（bit）8个位是一个字节（BYTE）2个BYTE是一个字（WORD）2个WORD是一个双字（DWORD）
13. stdin()//键盘
    stdout()//屏幕
    stderr()//代表出错定位？？？
    stdprn()//打印机
14. 结合性（优先级相等的情况下，计算的方向），优先级，解析复杂表达式
15. 赋值运算符会自动进行类型转换；
16. 侵入式赋值 //(a=b=c=10)这是侵入式赋值；
17. 等号左边能赋值的是左值；
18. 前缀自增（减）立刻复制(i=i+1 也是立刻赋值)，后缀自增（减）稍好复制；
19. 逻辑与（强行关闭要关闭的灯泡，其他的不变），逻辑或(强行打开需要打开的灯泡，其他不变)，异或（相同不行(为0)，不同可以(为1)），左移（乘以2）（移动一圈后还原），右移（除以2）（移动一圈后还原） 
20. goto, while(), do while(), for(), 递归；五种循环
21. if() else, switch() case default, break;  continue; 
22. 逻辑表达式，关系表达式；（注意 && 和 || 的短路效应）
23. 整数的极限，limits(求极限)
24. 8进制0开头，16进制0x开头；
25. 10(正常的int),10u(unsigned int),10L(长整型)；（注意整数常量的后缀）
26. volatile int a =1; //告诉编译器不要优化代码；按部就班的执行；
    register int a =0;//a不在内存里，在寄存器里；可以优化cpu和内存之间的交换次数；要注意：cpu没有那么多寄存器，不够会忽略
27. long long 用 %lld 打印，8个字节的整数；
28. long double 用 %llf 打印，windows下可以用%lf,超过8个字节得用%llf。？？？
29. float (%e, %f, %g);  double(%le, %lf, %lg), long double(%Le, %Lf, %Lg);
30. short int 等价于 short ; long int 等价于 long;
31. 窄字符，宽字符必须要懂：
``` c
    #include<locale.h> //本地化的？？？
    //一个宽字符可以用%c%c打印，也可以用%s打印;
    //Unicode 字符集（宽字符集）,或者 多字节字符集;
    MessageBoxA(0,"A我的","A我的",0); //多字节的字符集；指定窄字符
    MessageBoxW(0,L"W我的",L"W我的",0);//指定宽字符(unicode)
    MessageBox(0,L"0我",L"O我",0)//更具设定
    MessageBox(0,TEXT("K我"),TEXT("K我"),0);//兼容显示
    #include<locale.h>//本地化头文件？
    int main()
    {
        wchar_t ch = L'我';//字符
        wchar_t *pch = L"锄禾,日，当午";//字符串
        setlocale(LC_ALL,"chs");//设置本地化;也可（zh-CN）
        wprintf(L"%ls",pch);//打印宽字符串
        wprintf(L"%lc",ch);//打印宽字符
    }
```

32. 分装一个宽字符串，实现增删查改；
33. char c = toupper(97); 小写转大写；
34. 缓存去的概念 //必须理解；FILE的结构win（不同平台不同）
```c
    struct _iobuf //缓存区文件结构
    {
        _ptr;当前缓存区内容指针，
        _cnt;//缓存区还有多少字符，
        _base;//缓冲区的起始地址；
        _flag;//文件流的状态，是否错误或结束
        _file;//文件描述符
        _charbuf;//双字节缓冲，缓冲2个字节；
        _bufsiz;//缓冲区大小
        _tmpfname;//临时文件名
    };
```
    stdout stdin 不需要刷新，会及时更新，非缓冲；
    其他file  用fflush,刷新缓冲区；
35. sizeof()为运算符；strlen()为函数（求字符串长度）
36. typedef 使用（争强可移植性）； 
37. 数组需要理解顺序排列，指针访问，选择排序，冒泡排序，插入排序。
38. 指针循环数组，for(int *p = a, p < a + 10; p++)用5种循环尝试
39. 非void函数要有返回值（return 返回类型），void类型函数不能为右值；
40. 理解行参，和实参，
41. 函数参数传递的顺序是从右到左；
42. 数组是唯一没有副本机制的，传递地址；数组退化成指针，指针数组退化成2级指针；
43. 函数改变一个外部变量，需要一个地址，改变一个外部指针，需要一个二级指针
44. exit 任何位置都能退出程序（exit(0)正常关闭exit(1)异常退出会记录）；
45. 递归 边界条件（条件满足递归返回，条件不满足递归前进）
46. 了解函数的可变参数的使用；
47. 内联函数 c语言的内联函数就是用define，不需要等待函数返回（提升程序运行效率），内嵌在函数里执行（如： #define X(n)  n+=2 ）
48. 回调函数 要 学会劫持
49. 指针是变量（数据类型），存储的是地址 ，类型决定解析怎么解析！解析的步长； 
50. 必须搞定快速排序法；
51. 指针的运算，+ -，指针的运算与类型密切相关；指针与指针之间的减法（求中间元素个数）；
52. 指针遍历数组，二级指针，遍历指针数组，指向函数指针遍历函数指针数组；
53. int a[10] ( int *),  int *a[10]  (int **)
54. int a[3][4] (int (*)[4]) //*a, &a, a 的区别；
55. char *p = "21342"; char str[100] = "23423"理解指针与数组的区别，字符串/0结尾； 
56. 字符串strcpy,strstr,strcat,strcmp, memset(开始地址，’\0'，长度)； //清零，memcpy();//内存拷贝， 头文件<memory.h>
57. 字符串函数 puts, gets, printf, scanf, sprintf, sscanf,
58. 预编译，#include（包含任何文件，替换里面的内容）
59. #define的作用范围在#define和#undef之间，如果没有#undef就是#define开始下面到结束都能使用；
60. 条件编译，条件的判断只能是常量，（如果条件1和条件2同时成立只执行第一个）；
``` c
    #if 条件
    满足条件需要执行的代码； 
     #elif 2个条件
    满足条件2需要执行的代码； 

    #esle     //其他情况
    都不成立需要执行的代码； 

    #endif  //条件结束
    ////////////////////////////////////////////////////////////////////////////////////////////
    #indef MM  //如果定义了MM这个宏 就执行下面语句没有就不执行；开关开启关闭功能
    需要执行的代码;  
    #endif //结束作用范围；
    /////////////////////////////////////////////////////////////////////////////////////////////
    #ifndef MM  //如果定义了MM这个宏 就不执行下面语句；没有定义就执行下面语句，反开关
    需要执行的代码；
    #endif //结束作用范围；
```
61. #  标识符 添加""      ##链接标识符，  #define       \ 单斜杆代表链接下一行
62. 头文件一般只存放声明, 避免重复包含， 如果要存放定义需要使用条件编译防止从复包含；
63. 结构体与数组都是聚合变量，不同点：数组都是同类型数据，结构体可能有不同类型类型；数组通过下标定位元素，结构体通过元素定位元素。
64. c语言结构体不可以有方法，C++的类可以，C语言结构体内部包含函数指针（可以实现内？）；
65. 结构体只有在初始化时可以直接赋值，可以用另一个已经赋值的结构体变量整体复制（如果在堆上操作这个叫做浅拷贝）；
66. 结构体，共用体；
67. 了解枚举
``` c
enum  A
{
    军长, 师长, 旅长
};
```
68. 位域   int num : 3; //使用二进制的 3个位；
69. 内存分配的函数 realloc()//增加空间 ，malloc()//分配空间不清零， calloc()分配空间清零
70. 链表和数组的优缺点：链表删除，插入是优点，数组查询，修改是优点，二叉树可以综合2个方式的有点，
71. 函数指针，可以实现回掉，（劫持）；
72. 指针数组，数组指针
73. 声明四大变量
74. （VC 只是建议，GCC是强制），volatile 从内存读取 （防止变量被意外修改而不知道），register 寄存器变量
75. gcc用-S 是把c语言代码转化为汇编语言代码
76. 加%-3d靠左对齐保证3位
    加%3d靠右对齐最少保证3位
    加%03d靠右对齐左边空位补0
    加%.3f表示保留小数点后3位
    加%3.3f表示右对齐有3个位以上，保证小数点后3位
77. 1) 结构体变量的大小，一定能够被其最大类型成员的大小整除，也就是它的整数倍。
    2) 结构体每个成员相对于结构体首地址的偏移量，都是这个成员大小的整数倍。
78. 
``` c++
	FILE *fp = fopen("a.txt","rb");
	int length = 0; // 定义一个变量，用来接收文件的长度
	fseek(fp, 0, SEEK_END);//将文件内部读写指针移动到文件末尾
	length = ftell(fp); //获取文件指针的位置，通过ftell()来得到文件的长度
	rewind(fp); 	// 将文件指针fp重新指向文件开头
``` 
79. 文件打开模式：
		r 	以只读的方式打开文件，前提这个文件必须存在(默认是文本文件 t)
		r+	以读写的方式打开文件，前提这个文件必须存在
		rb+ 以读写的方式打开一个二进制文件，
		rt+ 同r+，以读写的方式打开一个文本文件

		w 	以只写的方式打开文件，如果这个文件存在，长度清0内容清空；如果文件不存在，则创建这个文件
		w+  以读写的方式打开文件，如果这个文件存在，长度清0内容清空；如果文件不存在，则创建这个文件
		wb	以只写的方式打开或新建一个二进制文件
		wb+ 以读写的方式打开或新建一个二进制文件
		wt+ 以读写的方式打开或新建一个文本文件

		a 	以追加的方式打开一个只写文件，如果文件不存在，则创建该文件；如果文件存在，则写入的数据追加到文件尾部，原来的内容也会保留
		a+  以追加的方式打开一个读写文件，如果文件不存在，则创建该文件；同上
		ab+ 以追加的方式打开一个读写二进制文件，如果文件不存在，则创建该文件；同上
80. 内存分配：
``` c++
    malloc(n * sizeof(int));
	    请求n个连续的、每个长度是一个int大小的空间，如果创建成功，就返回这些空间的首地址，如果创建失败，返回 NULL

    calloc(n, sizeof(int));
	    请求n个连续的、每个长度是一个int大小的空间，如果创建成功，就返回这些空间的首地址，如果创建失败，返回 NULL。
	    和 malloc()不同之处在意, calloc() 会把这个空间的值初始化为 0;

    realloc(p, sizeof(int) * n);
	    给一个已经分配地址的指针p重新分配空间，参数 p 是原来空间的首地址，sizeof(int) * n 是重新申请的空间大小;

    free(p);
	    free(p) 只是释放了所申请的内存，将这个内空空间标记为可用，就是可以被自己或者其他进程使用，但是并不改变p的值;
	    p所指向的内存以及被释放了，所以其他代码有可能会改写这里的内容，就相当于这个指针指向了自己未知的数据，所以叫野指针;
	     为了避免这种情况，我们在 free(p)之后，最好将 p = NULL;
```
81. 所谓内存四区
stack 栈区：是由编译器自动分配和回收，主要是存放函数参数的值，局部变量的值。先进后出，后进先出。
heap 堆区：是由程序员自己申请分配和释放，需要用到malloc() calloc() realloc()函数来申请创建，用free()函数来释放。如果不释放，会造成野指针。
data 数据区：主要包括了 静态(全局)区 和 常量区 全局区(静态区，标有 static 的)：全局变量、静态变量存放在这里
code 代码区： 用于存放编译后的可执行代码，二进制码，也可以叫机器码;
82. 指针数组：就是一个数组，这数组每个元素都是一个指针，他在内存空间中占用了n个指针大小的存储空间。
    数组指针：就是一个指针变量，在C语言里用来指向一个数组的首地址，他在内存空间中占用一个指针大小的存储空间，但是注意这个指针指向的是一个常量。
    二级指针p 和 二维数组p 的区别：
    	int **p：这是一个整型的二级指针，p是可变的句柄，我们可以让它指向任何我们想让它指向的地方，所以不需要指定大小。
		int p[n][m] = { 0 }: 这是一个整型的二维数组，p代表一块内存空间的地址，p就是引用了这个内存地址的句柄/钥匙，
			这块内存空间的大小是 sizeof(int) * n * m，这个p就是一个不可变的常量，他永远都只能指向这块内存。
83. ++a 是直接从变量a所在的内存地址中取值，并进行加1操作，再执行表达式
    a++ 是编译器会重新弄个寄存器来临时保存a的值，然后执行表达式，执行完之后，再把a的值自增1，再把a拿回内存。
84. 指针常量  int *const p指向的地址不可修改，也就是不能再指向别的地方啦，但是可以修改它所指向的地址里的内容
    常量指针 const int *p 是一个指向常量的指针，它所指向的地址里的内容不可修改，但是可以修改这个指针指向的地址。
85. C程序执行时候，先入栈的数据在栈底，为高地址；后入栈的数据在栈顶，为低地址。
86. 大端：就是把数值的高位字节放在内存的低位地址上，把数字的低位字节放到内存的高位地址上。
    小端：就是把数值的高位字节放在内存的高位地址上，把数字的低位字节放到内存的地位地址上。
