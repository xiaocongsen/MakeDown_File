# c++后台开发面试常见知识点总结（一）c++基础
指针和引用的区别
extern,const,static,volatile关键字
#define 和const的区别
关于typedef和#define;
C++程序中内存使用情况分析（堆和栈的区别）
new 与 malloc的异同处，new和delete是如何实现的。
C和C++的区别
C++中的重载，重写，重定义（隐藏）的区别：
析构函数一般写成虚函数的原因。
构造函数为什么一般不定义为虚函数
构造函数或者析构函数中调用虚函数会怎样。
析构函数能抛出异常吗
纯虚函数和抽象类
多态的实现条件，虚指针vptr, 虚函数表vbtl
深拷贝和浅拷贝的区别（举例说明深拷贝的安全性） 
什么情况下会调用拷贝构造函数（三种情况）
struct内存对齐方式，为什么要对齐？怎么修改默认对齐方式？struct,union
内存泄露的定义，如何检测与避免？内存检查工具的了解。
成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）
必须在构造函数初始化列表里进行初始化的数据成员有哪些？
C++的调用惯例（C++函数调用的压栈过程）
C++的四种强制转换 static_cast，const_cast，dynamic_cast，reinterpret_cast
多重继承，菱形结构，虚基类，虚继承，以及在多继承虚继承下多态的实现，虚继承下对象的内存分布
内联函数有什么优点？内联函数与宏定义的区别？
STL容器 迭代器失效总结.
对继承和组合的理解
c++ main函数执行之前需要做哪些准备
智能指针，shared_ptr的循环引用导致的内存泄漏怎么解决？
类成员变量用memset()设置会有什么问题？
STL alloc实现，alloc的优势和局限，STL中其他的配置器
单例模式；不能被继承的类；定义一个只能在堆上（栈上）生成对象？
cmake和makefile的区别   简述cmake到可执行文件的过程
问有没有用过shrink_to_fit，说一下作用，为什么用
char (*p) [5] 、char *p[5]、char (*p)()的区别？
如何防止一个类被拷贝
c++怎么实现一个函数先于main函数运行，后于main函数执行 
如何删除map中的奇数节点
C++的分离式编译  为什么C++类模板不支持分离式编译？
两个文件a,b，文件内部分别定义两个全局变量，用g 编译的时候如何保证两个全局变量初化顺序
哈希表的冲突处理和数据迁移
vector的容量扩张为什么是2倍  最好的策略是什么？reverse()
strcpy和strncpy的区别
malloc涉及的系统调用
C++11新特性? lambda表达式, =default;, =deleted 函数
C语言程序能不能直接调用C++语言编写的动态链接库。
C的restrict关键字：
虚函数表存储在静态存储区
面向对象的三大特性，结合C++语言支持来讲。
红黑树性质
malloc的底层实现
++iter和iter++那个好
用 c 实现重载 ?
如何突破private的限制？
如何设计一个好的字符串hash函数
 （1） 指针和引用的区别.

语法上：指针和引用没有关系，引用就是一个已经存在的对象的别名。对引用的任何操作等价于对被引用对象的操作。

1.当引用被创建时，它必须被初始化。而指针则可以在任何时候被初始化。未初始化的引用不合法，未初始化的指针合法但危险。（悬空指针）

2.一旦一个引用被初始化为指向一个对象，它就不能被改变为对另一个对象的引用。而指针则可以在任何时候指向另一个对象。

3.不可能有NULL引用。必须确保引用是和一块合法的存储单元关联。因为不存在指向空值的引用，所以在使用引用之前不需验证它的合法性，而使用指针需要验证合法性。所以使用引用的代码效率要比使用指针的要高。

底层实现上(汇编层)：引用是通过指针实现的。在程序一层只要直接涉及对引用变量的操作，操作的总是被引用变量，编译器实现了一些操作，总是在引用前面加上*。实际上如int a=0;int &b=a;中变量b中存放的是a的地址，int*const b=&a;但编译器让对b的操作都自动为*b,

 

指针的大小：在32位系统中是4字节，在64位系统中是8字节。因为指针指示的是一个内存地址，所以与操作系统有关。但这个也不是绝对正确的，因为64位系统兼容32位，对应的32程序的指针也是32位的，此时使用sizeof()得到的便是4(即32位）,例如编写win32程序时，指针就是32位。

 

（2） extern,const,static,volatile关键字（定义，用途）

extern关键字的作用:

1、extern用在变量或者函数的声明前，用来说明“此变量/函数是在别处定义的，要在此处引用”。extern声明不是定义，即不分配存储空间。也就是说，在一个文件中定义了变量和函数， 在其他文件中要使用它们， 可以有两种方式：1.使用头文件，在头文件中声明它们，然后其他文件去包含头文件；2.在其他文件中直接extern，就可以使用。

2、extern C作用：extern “C” 不但具有上述传统的声明外部变量的功能，还具有告知C++链接器使用C函数规范来链接的功能。 还具有告知C++编译器使用C规范来命名的功能。（因为C++支持函数的重载，C++编译器如果以C++规范翻译这个函数名时会把函数名翻译得很乱。）

 

static关键字的作用：

1、函数体内static变量的作用范围为该函数体，该变量的内存只被分配一次，其值在下次调用的时候仍然维持原始值，要是函数体内有对该变量进行更改的行为，再次访问时变量的值是更改后的值。

2、 在文件内的static全局变量和static全局函数可以被文件内可见，不能被其他文件可见。其他文件内可以有相同名字的其他的对象和函数，即文件范围的static可以限定变量在在文件范围内部，对其他文件不可见。而非static全局变量和全局函数可以在文件间使用。

3、在类中的static成员变量属于整个类所有，对类的所有对象只有一份拷贝。存储在静态存储区。静态数据成员可以被初始化，初始化在类体外进行，而前面不加static，以免与一般静态变量或对象相混淆；若未对静态数据成员赋初值，则编译器会自动为其初始化为0。全局变量和静态变量存储在静态数据区，在全局静态数据区，内存中所有的字节默认值都是0x00。

4、在类中的static成员函数属于整个类所有，static成员函数不接受this指针，没有this指针，因而只能访问类的static成员变量和static成员函数。不能作为虚函数。

    不能将静态成员函数定义为虚函数：虚函数依靠vptr和vtable来处理。vptr是一个指针，在类的构造函数中初始化，并且只能用this指针来访问它，因为它是类的一个成员，并且vptr指向保存虚函数地址的vtable.对于静态成员函数，它没有this指针，所以无法访问vptr. 这就是为何static函数不能为virtual。

   虚函数的调用关系：this -> vptr -> vtable ->virtual function

 

const关键字的作用：const意味着“只读”， const离谁近，谁就不能被修改；

1、想要阻止一个变量被改变，可以使用const关键字。在定义该const关键字时，通常要对它进行初始化，因为以后再也没有机会去改变它。

2、对于指针来说，可以指定指针本身为const，也可以指定指针所指向的数据为const，或者二者同时指定为const。

3、在一个函数声明中，const可以修饰形参，表明它是一个输入参数，在函数内部不能改变其值。如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用 const 来限制。

4、对于类的成员函数，若指定为const，则表明其实一个常函数，只有类的成员函数有常函数的说法，不能修改类的非静态成员变量。当确定类成员函数不会改变成员变量时，一定将其设为const的；类的const的对象只能调用其const成员函数，因为调用非const函数就有改变变量属性的风险。

5、对于类的成员函数，有时候必须制定其返回值为const，以使得其返回值不能为左值。效率考虑，参数传递，返回值尽量返回const&,除了必须值返回（返回的是一个函数内的临时对象，离开作用域对象清除，此时不能引用返回，必须值返回。）和可变引用&（如对象的操作符重载，需要连续赋值的情况，或cout的情况，必须使用可变引用）

6. const修饰成员变量，必须在构造函数列表中初始化；同时成员数据为引用的也必须在构造函数列表中初始化；static成员数据的初始化，放在类定义外，不加static，若static成员数据没有初始化，则默认为0；

 

volatile关键字的作用：

volatile int iNum = 10;

volatile 指出 iNum 是随时可能发生编译器觉察不到的变化的变量，变量可能被某些编译器未知的因素（比如：操作系统、硬件或者其它线程等更改），编译器觉察不到。

程序执行中每次使用它的时候必须从原始内存地址中去读取，因而编译器生成的汇编代码会重新从iNum的原始内存地址中去读取数据。而不是只要编译器发现iNum的值没有发生变化（因为可能是已经发生了变化编译器觉察不到），就只读取一次数据，并放入寄存器中，下次直接从寄存器中去取值（优化做法），而是重新从内存中去读取（不再优化）.

 

（3） #define 和const的区别（编译阶段、安全性、内存占用等）

1编译器处理方式不同
　　define宏是在预处理阶段展开。
　　const常量是编译运行阶段使用。
2 类型和安全检查不同
　　define宏没有类型，不做任何类型检查，仅仅是展开。
　　const常量有具体的类型，在编译阶段会执行类型检查。
3 存储方式不同
　　define宏仅仅是展开，有多少地方使用，就展开多少次，不会分配内存。
　　const常量会在内存中分配(可以是堆中也可以是栈中)

 

（4）关于typedef和#define;

typedef 定义一种类型的别名，不同于宏，它不是简单的字符串替换。如：

typedef void (*pFunParam)(int); pFunx b[10]; 定义了一个函数指针类型的数组，该函数指针指向的函数原型void fun(int)的函数实体

 

typedef 与 #define的区别案例：

typedef char *pStr1;    #define pStr2 char *;    pStr1 s1, s2;     pStr2 s3, s4; 
在上述的变量定义中，s1、s2、s3都被定义为char *，而s4则定义成了char，不是我们所预期的指针变量，根本原因就在于#define只是简单的字符串替换typedef则是为一个类型起新名字。
STL中通过将typedef 写在类内部和模板的泛化偏特化，特别针对指针类型实现迭代器的特性萃取。 struct里边写typedef int Aa并不会使得 对象的空间增大。

 

（5）C++程序中内存使用情况分析（堆和栈的区别）

 

C++中，内存分成5个区，他们分别是栈、堆、自由存储区（可以和堆不区分）、全局/静态存储区，常量存储区。一个由C/C++编译的程序占用的内存分为以下几个部分 ： 

栈（堆栈）：由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 。

堆： 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收 。注意它与数据结构中的堆是两回事，分配组织方式倒是类似于链表。常用C++的new/delete 运算符C的malloc()/free()，realloc等函数;

全局区（静态区）（static）: 全局变量和静态变量的存储是放在一块的，初始化的全局变量和静态变量在一块区域， 未初始化的全局变量和未初始化的静态变量在相邻的另一块区域。  程序结束后有系统释放 。函数和成员函数代码也存储在静态区。

常量区：存放常量，字符串，保证常量不被修改； 程序结束后由系统释放 。

程序代码区：存放函数体的二进制代码。静态区。

 

 

 

 

（6）new 与 malloc的异同处，new和delete是如何实现的。

new的实现过程: 

1.调用相应的 operator new(size_t) 函数，如果 operator new(size_t) 不能成功获得内存，则调用 new_handler() 函数用于处理new失败问题。可以用set_  new_handler()函数设置不同的new_handler() 函数实现不同的内存分配失败时的处理策略。operator new(size_t) 函数可以重载，但是必须包含size_t参数，不同的重载形式，对应到不同形式的new,如placement_new。 operator new的内存分配底层实现调用的也是malloc()函数。

2.在分配到的动态内存块上 调用相应类型的构造函数构造对象并返回其首地址。如果构造函数调用失败。则自动调用operate new对应的operator delete;释放内存。

new包含的分配内存和构造对象两个过程必须都要完成。

delete的实现过程: 

1，先调用对应内存上对象的析构函数、2调用相应的 operator delete(void *) 函数。 operator delete(void *)也是调用free()释放内存。

new 与 malloc的异同处：1，new/delete属于运算符，malloc/free属于库函数。2.malloc在申请内存空间失败以后会返回一个null指针，而new在申请内存空间失败以后会返回一个异常。也可以使用nothrow让new失败返回空指针,照顾c程序员的编程习惯。3.malloc只负责申请内存，他不能对内存进行初始化，new不仅能申请内存，还可以对内存进行初始化和调用对应对象的构造函数。new是C++的运算符，底层的内存分配动作仍然是通过malloc()实现，通过new_handle引入对内存分配失败的处理机制。New没有类似relloc的机制。

malloc分配的内存不够的时候，可以用realloc扩容。realloc是从堆上分配内存的。当扩大一块内存空间时，realloc()试图直接从堆上现存的数据后面的那些字节中获得附加的字节，如果能够满足，自然天下太平；如果数据后面的字节不够，那么就使用堆上第一个有足够大的自由块，现存的数据然后就被拷贝至新的位置，而老块则放回到堆上。这句话传递的一个重要的信息就是数据可能被移动。使用realloc无需手动把旧的内存空间释放. 因为realloc 函数改变地址后会自动释放旧的内存。

new如果分配失败了会抛出bad_alloc的异常，而malloc失败了会返回NULL。因此对于 new，正确的姿势是采用try...catch语法，而malloc则应该判断指针的返回值。为了兼容很多c程序员的习惯，C++也可以采用new(nothrow)的方法禁止抛出异常而返回NULL。   new(nothrow)也是通过重载operator new实现的一种placement new。New是使用new hander 处理内存分配失败的情况。

assert 一种预处理宏，使用单个表达式作为断言条件。若条件为false, assert输出信息并终止程序的执行。为true do nothing。

 

（7） C和C++的区别

C++ =C+OOP（面向对象，多态）+GP（泛型编程，模板，STL，模板元编程）+异常处理。


 sizeof()类的大小：

class A {};: sizeof(A) = 1;//空类大小为1；g++中每个空类型的实例占1字节空间。
class A { virtual Fun(){} }; sizeof(A) = 4;: //存在虚函数，即存在一个虚指针

class A { static int a; };: sizeof(A) = 1;//静态成员不算类的大小，和空类一样
class A { int a; };: sizeof(A) = 4;
class A { static int a; int b; };: sizeof(A) = 4;

 

（8）C++中的重载，重写，重定义（隐藏）的区别：

重载：全局函数之间或同一个类体里的成员函数之间，函数名相同，参数不同（参数个数，类型）。注意成员函数是否是const的也是不同的重载。函数是否是const只有成员函数。函数返回值不参与重载判定。

重写：子类对父类的重写，要求子类函数与父类函数完全相同，除了修饰符可以不同，比如父类private，子类可以是public。此外，最重要的一点就是，父类的函数必须是虚函数，也就是要有virtual来修饰。父类的虚函数，子类可以重写出自己的版本，可以不重写直接继承父类的版本。对于父类的纯虚函数，子类必须重写自己的版本；有纯虚函数函数的类为抽象类，抽象类不可实例化。抽象基类类似于Java的接口，都不可实例化。抽象基类中的纯虚函数类似于接口中的方法，实现接口的类必须实现接口中的方法。

重定义：子类有父类同名函数，父类的函数就会被隐藏，调用子类对象只能调用子类的函数。这种情况只是简单的作用域限制，不具有面向对象的特性。


（9）析构函数一般写成虚函数的原因。

 

什么时候类需要定义析构函数：如果类的数据成员中不存在成员（指针）与动态分配的内存相关联，我们一般不用自己定义析构函数，而是采用默认的析构函数析构类对象。一旦与动态分配的内存相关联，为了防止内存泄露，我们需要自己定义析构函数，手动释放动态分配的内存。因为系统默认的析构函数是无法帮助释放动态内存的。因为系统只会释放栈内存，分配的动态内存（堆内存）必须由程序手头释放。

三法则：如果一个类需要析构函数，几乎也需要定义赋值构造函数和重载赋值操作符。因为此时类的成员有指针，此时不能使用默认的复制构造，赋值运算符。

 

析构函数一般写成虚函数的原因：

在类的继承体系中，在分析基类析构函数为什么要定义为虚析构函数之前，我们要先明白虚函数存在的意义就是为了动态绑定，实现面向对象的特性之一 ：多态。

我们知道通过基类的指针或者引用可以实现对虚函数的动态绑定，那么当我们通过一个基类指针或者引用来析构一个对象时，我们是无法判断基类现在绑定的对象是基类还是派生类，如果析构函数不是虚函数，那么基类指针只会调用基类的析构函数，如此就发生了一些不该发生的事。只有将析构函数定义为虚函数，才能通过动态绑定，调用对应的析构函数版本，正确的析构类对象。

可以这么说:任何class只要有virtual函数都几乎确定也要有一个virtual析构函数(引用自Effective C++ 条款7)

（10）构造函数为什么一般不定义为虚函数

构造函数不能为虚函数主要有以下两点：

1、必要性分析：当定义派生类对象时，它会主动依次调用构造函数，顺序为基类的构造函数->一级派生类构造函数->二级派生类构造函数….直到当前派生类的构造函数调用完毕为止，到此派生类对象生成。 而虚函数存在的意义为动态绑定，从上一段话可知，它会从基类开始依次自动调用相应的构造函数，根本就不存在动态绑定的必要。

2、内存角度分析： 
构造函数的作用是生成相应的类对象。虚函数的动态绑定是依据一张虚函数表来确认的最终绑定到哪一个虚函数版本。 而调用构造函数之前，我们对类对象所做的操作仅限于分配内存，还没有对内存进行初始化。此时，内存空间上也不存在虚函数表，因此，按照这样的执行顺序，虚函数的动态绑定是实现不了的。


（11）构造函数或者析构函数中调用虚函数会怎样。

从语法上讲，调用完全没有问题。但是从效果上看，往往不能达到需要的目的。

1.构造：派生类对象构造期间会首先进入基类的构造函数，在基类构造函数执行时继承类的成员变量尚未初始化，此时调用虚函数，调用的一定是基类的虚函数版本，因为继承类的成员变量尚未初始化，此时对象类型是基类类型，vptr指向的也是基类的vptb,调用不到派生类的虚函数版本。此时虚函数和普通函数没有区别了。起不到多态的效果。

2.析构：假设一个派生类的对象进行析构，首先调用了派生类的析构，然后再调用基类的析构时，遇到了一个虚函数，这个时候有两种选择：Plan A是编译器调用这个虚函数的基类版本，那么虚函数则失去了运行时调用正确版本的意义；Plan B是编译器调用这个虚函数的派生类版本，但是此时对象的派生类部分已经完成析构，“数据成员就被视为未定义的值”，这个函数调用会导致未知行为。

总结：调用虚函数时，对应的基类或者派生类对象都必须是一个完整正确的对象状态。而在构造或者析构的过程中对象不是一个完整的状态。

 

（12）析构函数能抛出异常吗

不能。C++标准指明析构函数不能、也不应该抛出异常。

(1) 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。

(2) 通常异常发生时，c++的异常处理机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。

 

（13）纯虚函数和抽象类

virtual ~myClass()=0;有纯虚函数的类是抽象类，不能实例化，抽象类的功能类似于Java的接口。

 

 

 

 

 

 


（14）多态的实现条件，虚指针vptr, 虚函数表vbtl 

静态绑定和动态绑定：

静态绑定是通过重载和模板技术实现，在编译的时候确定。动态绑定通过虚函数和继承关系来实现，执行动态绑定，在运行的时候确定。

多态实现有几个条件：1.虚函数  2.一个基类的指针或引用指向派生类的对象

基类指针在调用成员函数(虚函数)时，就会通过对象的虚指针vptr去查找该对象的vptl虚函数表。虚函数表的地址vptr在每个对象的首地址。查找该虚函数表中该虚函数的函数指针进行调用。

每个对象中保存的只是一个虚函数表的指针，C++内部为每一个类维持一个虚函数表，该类的对象都指向这同一个虚函数表。

虚函数表中为什么就能准确查找相应的函数指针呢？因为在类设计的时候，派生类的虚函数表是直接从基类继承过来的，如果派生类的虚函数overiide某个基类的虚函数，那么虚函数表的函数指针就会被替换，因此可以根据指针准确找到该调用哪个函数。

虚函数在设计上还具有封装和抽象的作用。比如抽象工厂模式???

 

（15）深拷贝和浅拷贝的区别（举例说明深拷贝的安全性） 

浅拷贝在针对有指针的类时，会导致一个后果。两个指针指向同一块内存，在释放内存时，该内存会被释放两次，这就会有内存泄露的危险。

深拷贝，指先获取一块内存，然后将要拷贝的内容复制过去。两个指针指向不同的内存，就不会有内存泄露的风险了。

浅拷贝是没有定义拷贝构造函数时系统的默认拷贝构造函数的拷贝方式。

所以，在对含有指针成员的对象（有动态分配内存的对象）进行拷贝时，必须要自己定义拷贝构造函数，使拷贝后的对象指针成员有自己的内存空间，即进行深拷贝，这样就避免了内存泄漏发生。


（16）什么情况下会调用拷贝构造函数（三种情况）

用类的一个对象去初始化另一个对象时；当函数的形参值传递对象时；当函数的返回值是以值传递对象。

（17）struct内存对齐方式，为什么要对齐？怎么修改默认对齐方式？struct,union

从0位置开始存储； 成员变量存储的起始位置是该变量大小的整数倍； 结构体总的大小是其最大元素的整数倍，不足的后面要补齐；。当CPU访问正确对齐的数据时，它的运行效率最高。

Struct和union: union：

  (1). 共用体和结构体都是由多个不同的数据类型成员组成, 但在任何同一时刻, 共用体只存放了一个被选中的成员, 而结构体的所有成员都存在。

(2). 对于共用体的不同成员赋值,原来成员的值就不存在了,成为了无定义状态。 而对于结构体的不同成员赋值是互不影响的

   修改对齐方式：#pragma pack (2) /*指定按2字节对齐*/

#pragma pack () /*取消指定对齐，恢复缺省对齐*/

 

（18）内存泄露的定义，如何检测与避免？内存检查工具的了解。 

内存泄漏：内存泄漏指的是在程序里动态申请的内存在使用完后，没有进行释放，导致这部分内存没有被系统回收，久而久之，可能导致程序内存不断增大，系统内存不足。排除内存泄漏对于程序的稳健型特别重要，尤其是程序需要长时间、稳定地运行时。

检查工具：1.Linux下通过工具valgrind检测。2.VS中的

定位内存泄露：

2. 在windows平台下通过CRT中的库函数进行检测；（只适用于Debug环境下）

VS2013中在Debug环境下，通过CRT库本身的内存泄漏检测函数能够分析出内存泄漏，定位内存泄露的位置。 

检查方法：一.在main函数最后一行，加上一句_CrtDumpMemoryLeaks()。调试程序，自然关闭程序让其退出（不要定制调试），查看输出如下：

{453} normal block at 0x02432CA8, 868 bytes long. 

被{}包围的453就是我们需要的内存泄漏定位值(编译器的内存分配编号)，868 bytes long就是说这个地方有868比特内存没有释放。此时只能知道在哪一次的内存分配(编译器的内存分配编号)在程序结束没有释放发生内存泄露，并没有定位到具体的内存泄露的代码行。

接下来，定位代码位置：

在main函数第一行加上：_CrtSetBreakAlloc(453); 意思就是让程序执行到申请453这块内存的位置中断。然后调试程序，……程序中断了。查看调用堆栈。双击我们的代码调用的最后一个函数（栈顶），这里是CDbQuery::UpdateDatas()，就定位到了申请内存的代码：

 

在线上运行的时候：

对象计数

方法：在对象构造时计数++，析构时--，每隔一段时间打印对象的数量；若发现对象的个数只增不减的异常，则可以推测该类的对象发生了内存泄露。

优点：没有性能开销，几乎不占用额外内存。定位结果精确。

缺点：侵入式方法，需修改现有代码，而且对于第三方库、STL容器、脚本泄漏等因无法修改代码而无法定位。

Hook Windows系统API

方法：使用windows分配内存的系统Api：HeapAlloc/HeapRealloc/HeapFree（new/malloc的底层调用）,记录分配点，定期打印。

优点：非侵入式方法，无需修改现有文件，检查全面，对第三方库、脚本库等等都能统计到。

缺点：记录内存需要占用大量内存，而且多线程环境需要加锁。

 

（19）成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？

使用成员初始化列表定义构造函数是显式地初始化类的成员，如果不用成员初始化列表，那么类对象对自己的类成员分别进行的是一次隐式的默认构造函数的调用（在进入函数体之前）初始化类的成员，和一次拷贝赋值运算符的调用（进入函数体之后），如果是类对象，这样做效率就得不到保障。

类类型的数据成员对象在进入构造函数体前己经构造完成，也就是说在成员初始化列表处进行对象的构造工作，调用构造函数，在进入函数体之后，进行的是对己构造好的类对象赋值，又调用个拷贝赋值操作符才能完成（如果并未提供，则使用编译器默认的按成员赋值行为））。

 

（20）必须在构造函数初始化列表里进行初始化的数据成员有哪些？

(1) 常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
(2) 引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
(3) 没有默认构造函数的类类型，若没有提供显示初始化式，则编译器隐式使用成员类型的默认构造函数，若成员类没有默认构造函数，则编译器尝试使用默认构造函数将会失败。使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。

对象成员：A类的成员是B类的对象，在构造A类时需对B类的对象进行构造，当B类没有默认构造函数时需要在A类的构造函数初始化列表中对B类对象初始化

类的继承：派生类在构造函数中要对自身成员初始化，也要对继承过来的基类成员进行初始化，当基类没有默认构造函数的时候，通过在派生类的构造函数初始化列表中调用基类的构造函数实现。


（21） C++的调用惯例（C++函数调用的压栈过程）

在函数调用时，第一个进栈的是主函数中调用点后的下一条指令（函数调用语句的下一条可执行语句）的地址，然后是函数的各个参数，在大多数的C编译器中，参数是由右往左入栈的，然后是函数中的局部变量。注意静态变量是不入栈的。 静态变量在全局静态局。
    当本次函数调用结束后，局部变量先出栈，然后是参数，最后栈顶指针指向最开始存的地址，也就是主函数中的下一条指令，程序由该点继续运行。


（22）C++的四种强制转换static_cast，const_cast，dynamic_cast，reinterpret_cast

C的强制转换表面上看起来功能强大什么都能转，但是转化不够明确，不能进行错误检查，容易出错。

static_cast：

 static_cast用的最多，对于各种隐式转换如int转double，非const转const，void*转类型指针等。

C转换 ：(type) expression             C++转换：static_cast<type>(expression)  

 

const_cast：

只可以用来移除表达式的常量性； 

dynamic_cast：在多态的环境下向下转型。

用在继承体系多态环境中，将“指向基类对象的指针或引用”转型为“指向派生类对象的指针或引用”。若指向基类对象的指针或引用在运行时接受的一个派生类的对象，则转型成功。否则转型失败，会以一个null指针（当转型对象是指针）或一个exception（当转型对象是引用）表现出来。

reinterpret_cast：转换函数指针类型：

例：设有一数组，存储的是函数指针，有特定类型；

//FuncPtr是函数指针，指向某个函数，该函数无参数，返回类型为void。

typedef void (*FuncPtr)();

FuncPtr funcPtrArray[10];//funcPtrArray是个数组，有10个FuncPt

若想将以下函数的一个指针n放入该数组：

dosomething的类型与funcPtrArray接受的类型不同。funcPtrArray内各函数指针所指向的函数返回类型是void。

funcPtrArray[0]=&dosomething;//错

funcPtrArray[0]=reinterpret_cast<FuncPtr>(&dosomething);//对。

注：函数指针的转型动作不具移植性（C++不保证所有的函数指针都能以此方式重新呈现）。某些情况下这样的转型可能会导致不正确的结果。

（23）多重继承，菱形结构，虚基类，虚继承，以及在多继承虚继承下多态的实现，虚继承下对象的内存分布

 

 多重继承在菱形结构的情形下，往往导致virtual base classes(虚拟基类)的需求。在non-virtual base的情况下,如果派生类对于基类有多条继承路径,那么派生类会有不止一个基类部分,使用虚继承，让基类为virtual可以消除这样的复制现象。然而虚基类也可能导致另一成本:其实现做法常常利用指针,指向"virtual base class"部分,因此对象内可能出现一个(或多个)这样的指针。

 

（24）内联函数有什么优点？内联函数与宏定义的区别？

宏定义在预编译的时候就会进行宏替换；
内联函数在编译阶段，在调用内联函数的地方进行替换，减少了函数的调用过程的系统开销，但是使得编译文件变大。因此，内联函数适合简单函数，对于复杂函数，即使定义了内联编译器可能也不会按照内联的方式进行编译。
内联函数相比宏定义更安全，内联函数可以检查参数，而宏定义只是简单的文本替换。因此推荐使用内联函数，而不是宏定义。
虚函数不可以内联：内联在编译的时候替换，但只有在运行时才能确定调用哪个虚函数）

 

（25）STL容器迭代器失效总结.

 

vector 迭代器失效情况：

1.push_back()一定使得end（）返回的迭代器失效，若发生capacity（）增长，导致vector容器的所有迭代器都失效。因为发生了数据移动。

2. erase（）使得删除点和删除点后面的迭代器都失效。失效的迭代器不可以进行迭代器操作，如++iter,*iter,指向的是位置内存。但erase(iter)可以返回下一个有效的迭代器。erase的返回值是删除元素下一个元素的迭代器。这个迭代器是vector内存调整过后新的有效的迭代器。

list,set, map 迭代器失效情况：

使用了不连续分配的内存，删除当前的iterator，仅仅会使当前的iterator失效， erase迭代器返回值为void，所以要采用erase(iter++)的方式删除迭代器。如：

解析dataMap.erase(iter++);这句话分三步走，先把iter值传递到erase里面，然后iter自增，然后执行erase,所以iter在失效前已经自增了。

list中，erase(*iter)会返回下一个有效迭代器的值, erase(iter)也会返回void,也需使用erase(iter++)的方式删除迭代器。

deque迭代器失效情况：

 1.在deque容器首部或者尾部插入元素不会使得任何迭代器失效。2. 在其首部或尾部删除元素则只会使指向被删除元素的迭代器失效。3.在deque容器的任何其他位置的插入和删除操作将使指向该容器元素的所有迭代器失效。

 

（26.）对继承和组合的理解

继承是一种is-a关系，组合是一种has-a关系。在功能上来看，它们都是实现功能重用，代码复用的最常用的有效的设计技巧，都是在设计模式中的基础结构。类继承允许我们根据自己的实现来覆盖重写父类的实现细节，父类的实现对于子类是可见的，所以我们一般称之为白盒复用。对象持有通常用来实现配接，如，STL中deque和stack，整体类对部分类的功能的复用接口的修饰，使其成为另一种特定的面貌。整体类和部分类之间不会去关心各自的实现细节。即它们之间的实现细节是不可见的，故成为黑盒复用。

继承中父类定义了子类的部分实现，而子类中又会重写这些实现，修改父类的实现，设计模式中认为这是一种破坏了父类的封装性的表现。这个结构导致结果是父类实现的任何变化，必然导致子类的改变。然而组合这不会出现这种现象。对象的组合还有一个优点就是有助于保持每个类被封装，并被集中在单个任务上（类设计的单一原则）。这样类的层次结构不会扩大，一般不会出现不可控的庞然大类。而类的继承就可能出来这些问题，所以一般编码规范都要求类的层次结构不要超过3层。

一般优先优先使用对象组合，而不是类继承。

 

（27）c++ main函数执行之前需要做哪些准备

1.  设置栈指针

2.  将non-local static对象构造完成。

non-local static对象包括文件下（全局），命名空间下，类的static对象成员，non-local static对象要在main函数之前构造。函数中的static对象是local static对象，local static对象直到方法被调用的时候，才进行初始化，而且只初始化一次。local static 变量（局部静态变量）同样是在main前就已分配内存，第一次使用时初始化。所有的static对象都分配在全局区，程序结束才释放内存。

3. 将未初始化部分的赋初值：数值型short，int，long等为0，bool为FALSE，指针为NULL，等等，即.bss段的内容

4..运行全局构造器，估计是C++中构造函数之类的吧

5.将main函数的参数，argc，argv等传递给main函数，然后才真正运行main函数。，

全局变量、non-local static变量在main执行之前就已分配内存并初始化；local static 变量同样是在main前就已分配内存，第一次使用时初始化。

 

（28）手写智能指针？shared_ptr什么时候改变引用计数？weak_ptr如何解决引用传递？这些是线程安全的吗？线程安全的智能指针是哪一个？

智能指针：使用普通指针，容易造成堆内存泄露（忘记释放），二次释放，程序发生异常时内存泄露等问题等，使用智能指针能更好的管理堆内存。

shared_ptr的拷贝都指向相同的内存。每使用他一次，内部的引用计数加1，每析构一次，内部的引用计数减1，减为0时，自动删除所指向的堆内存。shared_ptr内部的引用计数是线程安全的，但是对象的读取需要加锁。

引用计数改变：构造函数中计数初始化为1；拷贝构造函数中计数值加1；析构函数中引用计数减1；赋值运算符中，左边的对象引用计数减/1，右边的对象引用计数加1；在赋值运算符和析构函数中，如果减1后为0，则调用delete销毁对象并释放它占用的内存

unique_ptr“唯一”拥有其所指对象，同一时刻只能有一个unique_ptr指向给定对象（通过禁止拷贝语义、只有移动语义来实现）。

weak_ptr是为了配合shared_ptr而引入的一种智能指针，不具有普通指针的行为，没有重载operator*和->,作用在于协助shared_ptr工作，观测资源的使用情况。成员函数use_count()可以观测资源的引用计数，成员函数lock()从被观测的shared_ptr获得一个可用的shared_ptr对象，从而操作资源。

 

shared_ptr的循环引用导致的内存泄漏怎么解决？

https://www.cnblogs.com/itZhy/archive/2012/10/01/2709904.html

使用weak_ptr

http://www.cnblogs.com/TianFang/archive/2008/09/20/1294590.html

 

类成员变量用memset()设置会有什么问题？

不能，因为memset会破坏成员变量对象的内部结构（都赋值为0），当类对象析构时，析构到该成员变量对象时，该成员变量对象不能正常进行析构操作，最终导致crash。

注：如果类包含虚函数，则不能用 memset 来初始化类对象。因为包含虚函数的类对象都有一个虚指针指向虚函数表（vtbl），进行memset操作时，虚指针的值也要被overwrite，这样一来，只要一调用虚函数，程序便崩溃。

 

(30)STL alloc实现，alloc的优势和局限，STL中其他的配置器

gnuC中使用了内存池设计，减小了小内存分配的分配次数，提高效率。减少内存的碎片化。但是同时内存池的设计只分配不释放（只拿不还，服务容器），alloc在运行期间不会释放分配的内存。这种占用可能使得其他的进程不能获得足够的内存。在gunc4.9 中有其他的配置器。给8k，16k,..., 128k比较小的内存片都维持一个空闲链表。

_pool_alloc, loki_allocator

（31）模板的用法与适用场景,模板泛化，偏特化，特化，可变模板参数，举出实例。

 

（29）单例模式，C++实现一个线程安全的单例类；用C++设计一个不能被继承的类；如何定义一个只能在堆上（栈上）生成对象？ fianl对象 

单例模式：一个类只能被实例化一次，并提供一个访问它的全局访问点。

 

饿汉和懒汉：懒汉式在第一次用到类实例的时候才会去实例化，通常需要用加锁机制实现线程安全。饿汉式在单例类定义的时候就进行实例化。使用no-local static变量存储单例对象，类一加载就实例化。会提前占用系统资源。

特点与选择：由于要进行线程同步，所以在访问量比较大，或者可能访问的线程比较多时，采用饿汉实现，可以实现更好的性能。这是以空间换时间。在访问量较小时，采用懒汉实现。这是以时间换空间。

 

分析：instance是非局部静态变量，在main执行前就分配内存并初始化，是线程安全的。潜在问题在于no-local static对象（函数外的static对象）在不同编译单元（可理解为cpp文件和其包含的头文件）中的初始化顺序是未定义的。

 

使用场景： 在整个项目中需要一个共享访问点或共享数据，或者类似的实体（有且只有一个，且需要全局访问），那么就可以将其实现为一个单例。

例如一个Web页面上的计数器，可以不用把每次刷新都记录到数据库中，使用单例模式保持计数器的值，并确保是线程安全的；

日志类，一个应用往往只对应一个日志实例；

管理器，比如windows系统的任务管理器就是一个例子，总是只有一个管理器的实例。

单例模式常常与工厂模式结合使用，因为工厂只需要创建产品实例就可以了，在多线程的环境下也不会造成任何的冲突，因此只需要一个工厂实例就可以了。

 

只能建立在堆上：将析构函数设为私有，类对象就无法建立在栈上了。当对象建立在栈上时，是由编译器分配内存空间的，编译器调用构造函数来构造栈对象。当对象使用完后，编译器会调用析构函数来释放栈对象所占的空间。编译器在为类对象分配栈空间时，会先检查类的析构函数的访问性，其实不光是析构函数，只要是非静态的函数，编译器都会进行检查。如果类的析构函数是私有的，则编译器不会在栈空间上为类对象分配内存。

只能建立在栈上：在类的内部重载operator new()，并设为私有即可。只有使用new运算符，对象才会建立在堆上，因此，只要禁用new运算符就可以实现类对象只能建立在栈上。

设计一个fianl类: 法一：构造析构放在私有，public中放一个static接口函数，用来创建和释放类的实例。，但是该类只能得到位于堆上的实例，而得不到位于栈上实例。

法二：友元函数；https://www.cnblogs.com/luxiaoxun/archive/2013/06/07/3124948.html

C++11中已经有了final关键字：作用是指定一个类成为一个不能被继承的类（final class），或者指定类的虚函数不能被该类的继承类重写（override），。

使用场景：当一个方法被final修饰后。表示该方法不能被子类重写。比如涉及到某些需要统一处理的需求。

 

cmake和makefile的区别   简述cmake到可执行文件的过程
 

make: 一个自动化编译工具,依据makefile文件(编译规则) 批处理编译多个源文件。

cmake：一个读入源文件，自动生成makefile文件的工具，cmakelist文件是cmake工具生成makefile文件的规则，cmakelist通常由程序员编写。

https://blog.csdn.net/weixin_42491857/article/details/80741060

 

问有没有用过shrink_to_fit，说一下作用，为什么用
把capicity减少到元素个数，减少容量

,如：vector<int>(ivec).swap(ivec);将 ivec  shrink_to_fit

 表达式vector<int>(ivec)建立一个临时vector，它是ivec的一份拷贝：vector的拷贝构造函数做了这个工作。但是，vector的拷贝构造函数只分配拷贝的元素需要的内存，所以这个临时vector没有多余的容量。然后我们让临时vector和ivec交换数据，这时，ivec只有临时变量的修整过的容量，而这个临时变量则持有了曾经在ivec中的没用到的过剩容量。最后，临时vector被销毁，因此释放了以前ivec使用的内存，收缩到合适。

  char (*p) [5] 、char *p[5]、char (*p)()的区别？指向数组的指针，指针数组，函数指针，
char (*p) [5]：定义了个指针，指针指向一个有5个char的数组；

char *p[5]：定义了一个数组，里面有5个指向char的指针；

char (*p)()：函数指针，指向 char fun();类型的函数；

 

如何防止一个类被拷贝
是将构造函数和拷贝构造函数声明为private,或者采用c++11的delete关键字，

delete关键字可用来禁用某种类型的函数，unique_ptr只能使用移动构造函数，使用delete关键字禁用了拷贝构造函数。

 

c++怎么实现一个函数先于main函数运行，后于main函数执行 
main函数执行前：定义在main( )函数之前的全局对象、静态对象的构造函数在main( )函数之前执行。

main函数执行后：全局/静态对象的析构函数会在main函数之后执行；可以用atexit（）来注册程序正常终止时要被调用的函数，并且在main函数结束时，调用这些函数，调用顺序与他们被注册时相反

无论程序是否正常退出，都可以用atexit（）来调用资源释放的函数；

如何删除map中的奇数节点
遍历删除，考虑迭代器失效问题

for(ITER iter=mapTest.begin();iter!=mapTest.end();++iter)
{ if（iter指向的元素是奇数）

    mapTest.erase(iter);

} //错误，erase会让迭代器会失效！

 

for(ITER iter=mapTest.begin();iter!=mapTest.end();)
{ if（iter指向的元素是奇数）

mapTest.erase(iter++);//正确，iter值传递之后，再++；

} 

for(ITER iter=mapTest.begin();iter!=mapTest.end();)
{ if（iter指向的元素是奇数）
iter=mapTest.erase(iter);// erase() 成员函数返回下一个元素的迭代器

} 

 

 

C++的分离式编译  为什么C++类模板不支持分离式编译？
C++的分离式编译：c++开发中广泛使用声明和实现分开的开发形式，其编译过程是分离式编译，就是说各个cpp文件完全分开编译，然后生成各自的obj目标文件，最后通过连接器link生成一个可执行的exe文件。一个编译单元（translation unit）是指一个.cpp文件以及它所#include的所有.h文件，.h文件里的代码将会被扩展到包含它的.cpp文件里，然后编译器编译该.cpp文件为一个.obj文件。.obj文件已经是二进制码，但是不一定能够执行，因为并不保证其中一定有main函数。当编译器将一个工程里的所有.cpp文件以分离的方式编译完毕后，再由连接器（linker）进行连接成为一个.exe文件。

C++类模板不支持分离式编译:模板代码的实现体在一个文件里,而实例化模板的测试代码在另一个文件里,编译器编译一个文件时并不知道另一个文件的存在,因此,模板代码就没有进行实例化,编译器自然不会为其生成代码,因此会抛出一个链接错误!

C++类模板不支持分离式编译，即我们必须把类模板的声明和定义写在同一个.h文件中；

 

函数重载
函数重载考虑参数个数，参数类型，不考虑函数返回值类型（函数调用时独立于上下文），

 

两个文件a,b，文件内部分别定义两个全局变量，用g 编译的时候如何保证两个全局变量初化顺序

全局变量  int   a   =   5;   int   b   =   a;  在不同文件中，不能保证b也等于5,也就是说不能保证a先初始化。

解决这种问题的方法是不直接使用全局变量，而改用一个包装函数来访问，例如   

 int   get_a()   
  {   
          static   int   a   =   5;   
          return   a;   
  }   


  int   get_b()   
  {   
          static   int   b   =   get_a();   
          return   b;   
  }   

这样的话，无论get_a和get_b是否定义在同一个文件中，get_b总是能够返回正确的结果，原因在于，函数内部的静态变量是在第一次访问的时候来初始化。 

 

哈希表的冲突处理和数据迁移。

处理冲突：hash表实际上由size个的桶组成一个桶数组table[0...size-1] 。当一个对象经过哈希之后。得到一个对应的value , 于是我们把这个对象放到桶table[ value ]中。当一个桶中有多个对象时。我们把桶中的对象组织成为一个链表。这在冲突处理上称之为拉链法。

负载因子： 如果一个hash表中桶的个数为 size , 存储的元素个数为used .则我们称 used / size 为负载因子loadFactor . 一般的情况下，当loadFactor<=1时，hash表查找的期望复杂度为O(1). 因此。每次往hash表中加入元素时。我们必须保证是在loadFactor <1的情况下，才可以加入。

数据迁移：Hash表中每次发现loadFactor==1时，就开辟一个原来桶数组的两倍空间（称为新桶数组），然后把原来的桶数组中元素所有转移过来到新的桶数组中。注意这里转移是须要元素一个个又一次哈希到新桶中的。

缺点：容量扩张是一次完毕的，期间要花很长时间一次转移原hash表中的全部元素。

改进： redis中的dict.c中的设计思路是用两个hash表来进行扩容和转移的工作：当第一个hash表的loadFactor=1时，假设要往字典里插入一个元素。首先为第二个hash表开辟2倍第一个hash表的容量。同一时候将第一个hash表的一个非空桶中所有元素转移到第二个hash表中。然后把待插入元素存储到第二个hash表里。继续往字典里插入第二个元素，又会将第一个hash表的一个非空桶中所有元素转移到第二个hash表中，然后把元素存储到第二个hash表里……直到第一个hash表为空。

      这样的策略就把第一个hash表全部元素的转移分摊为多次转移，并且每次转移的期望时间复杂度为O(1)。

 

vector的容量扩张为什么是2倍  最好的策略是什么？reverse()

vector 在需要的时候会扩容，在 VS 下是 1.5倍，在 GCC 下是 2 倍。

为什么是成倍增长，而不是每次增长一个固定大小的容量呢？
答：采用成倍方式扩容，可以保证push_back 常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度

为什么是以 2 倍或者 1.5 倍增长，而不是以 3 倍或者 4 倍等增长呢？
以 大于2 倍的方式扩容，下一次申请的内存会大于之前分配内存的总和，导致之前分配的内存不能再被使用。所以，最好的增长因子在 （1,2）之间。

数学上的证明：当 k =1.5 时，在几次扩展以后，可以重用之前的内存空间了

 

  reserve(n)：由于vector动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。因此，可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。只有当n>capacity()时，调用reserve(n)才会改变vector容量。

 

C语言里面字符串，strcpy和strncpy的区别？哪个函数更安全？

strcpy函数：把从src地址开始且含有NULL结束符的字符串赋值到以dest开始的地址空间，返回dest（地址中存储的为复制后的新值）。要求：src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。

 strncpy函数：将字符串src中最多n个字符复制到字符数组dest中(它并不像strcpy一样遇到NULL才停止复制，而是等凑够n个字符才开始复制），返回指向dest的指针。要求：如果n > dest串长度，dest栈空间溢出产生崩溃异常。

 

安全性分析：strncpy要比strcpy安全得多，strcpy无法控制拷贝的长度，不小心就会出现dest的大小无法容纳src的情况，就会出现越界的问题，程序就会崩溃。而strncpy就控制了拷贝的字符数避免了这类问题，但是要注意的是dest依然要注意要有足够的空间存放src，而且src 和 dest 所指的内存区域不能重叠，

 

malloc涉及的系统调用（说了brk指针和mmap，没说清楚，非常不满意）。

malloc调用brk或mmap系统调用去获取内存。malloc小于128k的内存，使用brk分配内存，malloc大于128k的内存，使用mmap分配内存，在堆和栈之间找一块空闲内存分配(对应独立内存，而且初始化为0)，

 

C++11新特性? lambda表达式, =default;, =deleted 函数

Lambda 表达式就是用于创建匿名函数的。

 

lambda表达式的本质就是重载了()运算符的类，这种类通常被称为functor，即行为像函数的类。因此lambda表达式对象其实就是一个匿名的functor。编译器自动将lambda表达式转换成函数对象执行

=default; 指示编译器生成该函数的默认实现。这有两个好处：一是让程序员轻松了，少敲键盘，二是有更好的性能。
与 defaulted 函数相对的就是 =deleted 函数, 实现 non copy-able 防止对象拷贝，要想禁止拷贝，用 =deleted 声明一下两个关键的成员函数就可以了：

 

C语言程序能不能直接调用C++语言编写的动态链接库。
不能，因为C++支持重载，在编译函数的声明时，会改写函数名（可以通过链接指示进行解决）；另外，C语言不支持类，无法直接调用类的成员函数（可以通过加入中间层进行解决）；C语言也不能调用返回类型或形参类型是类类型的函数。

 

C的restrict关键字：
restrict是c99标准引入的，它只可以用于限定和约束指针，并表明指针是访问一个数据对象的唯一且初始的方式. 即它告诉编译器，所有修改该指针所指向内存中内容的操作都必须通过该指针来修改, 而不能通过其它途径(其它变量或指针)来修改;这样做的好处是,能帮助编译器进行更好的优化代码,生成更有效率的汇编代码。

现在程序员用restrict修饰一个指针，意思就是“只要这个指针活着，我保证这个指针独享这片内存，没有‘别人’可以修改这个指针指向的这片内存，所有修改都得通过这个指针来”。由于这个指针的生命周期是已知的，编译器可以放心大胆地把这片内存中前若干字节用寄存器cache起来。

 

通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符。
 

虚函数表存储在静态存储区 
https://www.cnblogs.com/chenhuan001/p/6485233.html

 

重载、重写和重定义的区别
	1.重载：函数名相同，参数列表不同
	2.重写：也称为覆盖，派生类覆盖基类的虚函数。函数名，参数列表必须相同，返回类型一般也必须相同，存在一个例外（当类的虚函数返回类型是类本身的指针或引用时，上述规则无效。也就是说，如果D由B派生得到，则基类的虚函数可以返回B*而派生类的对应函数可以返回D*，只不过这样的返回类型要求从D到B的类型装换是可访问的）。
注：（1）静态函数不能被定义为虚函数，也不能被重载

（2）重写函数的访问修饰符可以不同

	3.重定义：也称为隐藏，派生类重新定义基类中有相同名称的非虚函数（有相同名称就可）
 

面向对象的三大特性，结合C++语言支持来讲。

 

	1.封装：
	1.封装实现了类的接口和实现的分离。封装后的类隐藏了它的实现细节，也就是说，类的用户只能使用接口而无法访问实现部分。
	2.封装有两个重要的优点：确保用户代码不会无意间破坏封装对象的状态；被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。
	2.继承
	1.继承使我们可以更容易地定义与其他类相似但不完全相同的新类。
	2.继承可以实现代码重用，提高软件开发的效率。
	3.多态：“一个接口，多种实现”，同样的消息被不同的对象接受时导致不同的行为。多态分为静态多态和动态多态。
	1.静态多态通过函数重载、模板实现；
	2.动态多态通过虚函数实现，当使用基类的指针（或引用）调用虚函数时将发生动态绑定，使用动态绑定，可以在一定程度上忽略相似类型的区别，而以统一的方式使用它们的对象。
多态的好处：可以忽略派生类和基类的区别，而以统一的方式使用派生类和基类的对象，提高了代码的复用性和可拓展性。

 

红黑树性质：红黑树是许多“平衡”搜索树中的一种，可以保证在最坏情况下基本动态操作的时间复杂度为O(lgn)。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出2倍，因而使近似于平衡。

红黑树须满足条件：

每个结点或是红色的，或是黑色的。
根节点是黑色的。
每个叶结点(NIL)是黑色的。
如果一个结点是红色的，则它的两个子结点都是黑色的。
对每个结点，从该结点到其所有后代结点的简单路径上，均包含相同数目的黑色结点。
AVL树和红黑树的区别：

	1.红黑树是近似平衡的二叉树，每次插入和删除操作最多只需要三次旋转就能达到平衡，实现起来也更为简单。
	2.平衡二叉树严格平衡的二叉树，每次插入和删除新节点需要旋转的次数不可预知，实现起来比较复杂。
 

malloc的底层实现：

malloc函数将可用的内存块连接为一个空闲链表。调用malloc函数时，它沿着空闲链表寻找一个大到足以满足用户所需要的内存块。然后，将该内存块一分为二。一块分配给用户使用，另一个块重新连接到空闲链表。当用户申请一个大的内存片段，而内存块被切分为小的内存片段，无法满足用户的请求时，malloc函数请求延时，将相邻的小的空闲块合并成大的内存块。如果找不到合适的内存块，就通过系统调用brk，将break指针向高地址移动，获取新的内存块，连接到空闲链表中。另外，如果所申请的内存大于128k，调用mmap在文件映射区域找一块空闲的虚拟内存。如果分配内存失败，会返回NULL指针。

 

++iter和iter++那个好？

前置版本的递增运算符避免了不必要的工作，它把值加1后直接返回改变了的运算对象。与之相比，后置版本需要将原始值存储下来以便于返回这个位修改的内容，如果我们不需要修改前的值，那么后置版本的操作就是一种浪费。对于相对复杂的迭代器类型，这种后置版本的操作就是一种浪费。

 

用 c 实现重载 ? 函数指针

如何突破private的限制？友元函数
用 C 模拟虚函数？

 

如何设计一个好的字符串hash函数

对于一个Hash函数，评价其优劣的标准应为随机性或离散性，即对任意一组标本，进入Hash表每一个单元（cell）之概率的平均程度，因为这个概率越平均，两个字符串计算出的Hash值相等hash collision的可能越小，数据在表中的分布就越平均，表的空间利用率就越高。

C++ 11 定义了一个新增的哈希结构模板定义于头文件 <functional>：std::hash<T>，模板类，（重载了operator()），实现了散列函数: unordered_map和unordered_multimap 默认使用std::hash; std::hash;实现太简单

同时，C++ STL 里面实现了一个万用的hash function 针对任何类型的

 

 

boost::hash 的实现也是简单取值。

DJBHash是一种非常流行的算法，俗称"Times33"算法。Times33的算法很简单，就是不断的乘33，原型如下：

hash(i) = hash(i-1) * 33 + str[i]，Time33在效率和随机性两方面上俱佳

https://blog.csdn.net/g1036583997/article/details/51910598














# c++后台开发面试常见知识点总结（二）网络编程
（1）TCP和UDP有什么区别？

 TCP是传输控制协议，提供的是面向连接的，可靠地字节流服务。使用三次握手建立连接，四次挥手释放连接。UDP是用户数据报协议，传输的是UDP数据报，是无连接的，而且没有超时重发机制。 TCP保证数据按序到达，提供流量控制和拥塞控制，在网络拥堵的时候会减慢发送字节数，而UDP不管网络是否拥堵。  TCP是连接的，所以服务是一对一服务，而UDP可以1对1，也可以1对多（多播），也可以多对多。

TCP可靠传输的保证：

停止等待协议：每发送完一个分组就停止发送，等待对方确认。收到确认后再发送下一个分组。无差错情况下收到确认再发送。如果发送方超过一段时间仍没有收到确认就会重新发送（超时重传）。因此发送完必须保留分组副本，分组和确认分组都必须编号，超时计时器应该比平均往返时间长一点。 

连续ARQ协议：发送方每收到一个按序到达的确认，就把发送窗口向前移动一个分组的位置。

滑动窗口机制：窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

UDP如何实现可靠传输：

在应用层模仿传输层TCP的可靠性传输。不考虑拥塞处理的简单设计。1、添加seq/ack机制，确保数据发送到对端。2、添加发送和接收缓冲区，主要是用户超时重传。3、添加超时重传机制。

注：1、发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x+1的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。2、时间到后，定时任务检查是否需要重传数据。

 

（2）建立和释放TCP/IP过程。
SYN表示建立连接，
FIN表示关闭连接，
ACK表示响应，
PSH表示有 DATA数据传输，
RST表示连接重置

三次握手过程：TCP提供的可靠数据传输服务，是依靠接收端TCP软件按序号对收到的数据分组进行逐一确认实现的。三次握手协议指的是在发送数据的准备阶段，服务器端和客户端之间需要进行三次交互：

第一次握手：客户端发送syn包(syn=j)到服务器，并进入SYN_SEND状态，等待服务器确认；

第二次握手：服务器收到syn包，必须确认客户的syn（ack=j+1），同时自己也发送一个SYN包（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；

第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，服务器收到此包，客户端和服务器进入ESTABLISHED状态，完成三次握手。

三次握手的原因：第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。

四次挥手： 数据传输结束后，通信双方都可以释放连接。现在客户端和服务器都处于ESTABLISHED状态，客户端应用进程向其TCP发出连接释放报文段，主动关闭TCP连接。客户端进入FIN_WAIT1（终止等待1）状态。然后服务器立刻确认，服务器进入CLOSE_WAIT(关闭等待)状态。此时TCP处于半关闭状态，客户端已经没有数据要发送了，如果服务器仍要发送数据，客户端仍然接收。客户端收到服务器的确认后，就进入FIN_WAIT2（终止等待2）状态，等待服务器发出连接释放报文。 如果服务器已经没有向客户端发送的数据，则服务器发送请求释放报文，服务器进入LAST_ACK（最后确认）阶段，等待客户端的最后确认。客户端在收到服务器的请求后，要发出确认，然后进入TIME_WAIT（时间等待）状态。此时，连接还未释放，必须等待2MSL后，客户端才进入CLOSED状态。服务器收到客户端最后的确认，进入CLOSED状态，连接释放。

四次挥手的原因：客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

TIME_WAIT：客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

1. 确保最后一个确认报文段能够到达。如果 服务端 没收到 客户端 发送来的确认报文段，那么就会重新发送连接释放请求报文段，客户端 等待一段时间就是为了处理这种情况的发生。

2. 等待一段时间是为了让本连接持续时间内所产生的所有报文段都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文段。

 

（3）抓包分析发现服务器保持了大量CLOSE_ WAIT 和TIME_WAIT套接字

 

在服务器的日常维护过程中，会经常用到下面的netstat命令查看TCP套接字的状态：

TIME_WAIT 814    CLOSE_WAIT 1   FIN_WAIT1 1   ESTABLISHED 634
SYN_RECV 2     LAST_ACK 1

常用的三个状态是：ESTABLISHED 表示正在通信，TIME_WAIT 表示主动关闭，CLOSE_WAIT 表示被动关闭。

因为linux分配给一个用户的文件句柄是有限的，而TIME_WAIT和CLOSE_WAIT两种状态如果一直被保持，那么意味着对应数目的通道就一直被占着，一旦达到句柄数上限，新的请求就无法被处理。

 

服务器保持了大量TIME_WAIT状态的套接字：TIME_WAIT是主动关闭连接的一方保持的状态。 对于基于TCP的HTTP协议，关闭TCP连接的是Server端，这样，Server端会进入TIME_WAIT状态，可 想而知，对于访问量大的Web Server，会存在大量的TIME_WAIT状态，维护这些状态给Server带来负担。

原因：大量出现这个状态往往说明系统的并发比较高，大量的连接建立和释放，

处理：优化系统内核参数让服务器能够快速回收和重用那些TIME_WAIT的资源。

 

服务器保持了大量CLOSE_WAIT状态的套接字：

原因：Server 程序处于CLOSE_WAIT状态，而没有跳转到LAST_ACK状态，说明Server还没有发FIN给Client，那么可能是在关闭连接之前还有许多数据要发送或者其他事要做，导致没有发这个FIN package。通常一个CLOSE_WAIT会维持至少2个小时的时间。如果有个恶意程序，给服务器造成一堆的CLOSE_WAIT，通常是等不到释放那一刻，系统就已经崩溃了。 

解决：修改TCP/IP的参数，来缩短2个小时这个时间：修改tcp_keepalive_*系列参数有助于解决这个问题。

 

5.IO模型：

阻塞IO，非阻塞IO，IO复用，信号驱动式IO，异步IO

同步IO和异步IO， 

阻塞IO和非阻塞IO。

对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中（），然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：1. 等待数据准备  2.将数据从内核拷贝到进程中 

当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据（对于网络IO来说，很多时候数据在一开始还没有到达。比如，还没有收到一个完整的UDP包。这个时候kernel就要等待足够的数据到来）。这个过程需要等待，也就是说数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。

5.1. 阻塞IO的特点就是在IO执行的两个阶段都被block了。

 

5.2.非阻塞 IO的特点是用户进程需要不断的主动询问kernel数据好了没有。如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。用户进程判断结果是一个error时，它就知道数据还没有准备好，于是它可以再次发送read操作。一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call（read），那么它（read）马上就将数据拷贝到了用户内存，然后返回。

5.3. I/O 多路复用的特点是通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。阻塞IO第一阶段是阻塞在recvfrom, . I/O 多路复用第一阶段是阻塞在select.

5.4. 异步 I/O不阻塞，用户进程发起read操作之后，立即返回，立刻就可以开始去做其它的事。不会对用户进程产生任何block。然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。

5.5. 信号驱动式IO

 

同步I/O和异步I/O: 同步I/O 需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。

 

6. select，poll，epoll的实现和区别

select:用户进程调用select函数后会阻塞，直到有描述符就绪（有数据可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可）函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。

优点：select目前几乎在所有的平台上都支持，有良好的跨平台支持。

缺点：1. 单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。2. 轮寻排查当文件描述符个数很多时，效率很低。poll通过一个可变长度的数组解决了select文件描述符受限的问题，但轮寻排查的问题未解决。epoll采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。

 

Poll: poll通过一个可变长度的数组解决了select文件描述符受限的问题，但轮寻排查的问题未解决。

 

epoll: 没有描述符限制。采用只返回状态发生变化的文件描述符，便解决了轮寻的瓶颈。

epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。

LT模式是默认模式，并且同时支持block和no-block socket.在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。

ET模式是高速工作方式，只支持no-block socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)。ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

Epoll的优势：1. 监视的描述符数量不受限制。2. IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是通过为每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数。所以epoll只返回状态发生变化的文件描述符。每个描述符就绪时自己调用回调函数上报给epoll。

epoll实现源码：(红黑树+就绪队列),为什么用红黑树实现，有哪些好处 ？

红黑树存储epoll所监听的套接字。当添加，删除或者修改（查找）一个套接字时（epoll_ctl），都在红黑树上去处理，红黑树本身插入和删除性能比较好，时间复杂度O(logN)。

List链表用于存储准备就绪的事件，当epoll_wait调用时，仅仅观察这个list链表里有没有数据即可。有数据就返回，没有数据就sleep，等到timeout时间到后即使链表没数据也返回。所以，epoll_wait非常高效。

EPOLLONESHOT:

背景：多线程环境下，一个SOCKET事件到来，数据开始解析，这时候这个SOCKET又来了同样一个这样的事件，而你的数据解析尚未完成，那么程序会自动调度另外一个线程或者进程来处理新的事件，这造成一个很严重的问题，不同的线程或者进程在处理同一个SOCKET的事件，这会使程序的健壮性大降低而编程的复杂度大大增加！！即使在ET模式下也有可能出现这种情况。如果对描述符socket注册了EPOLLONESHOT事件，那么操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次。。想要下次再触发则必须使用epoll_ctl重置该描述符上注册的事件，包括EPOLLONESHOT 事件。

EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里 。

 

7.流量控制和拥塞控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。拥塞控制是为了控制发送方发送速率降低整个网络的拥塞程度。拥塞控制4种算法：1.慢开始与拥塞避免 2.快重传与快恢复。

 

8. TCP协议是如何保证可靠传输的？如何用udp封装实现tcp ？

TCP通过序列号、检验和、确认应答信号、重发控制、连接管理、窗口控制、流量控制、拥塞控制实现可靠性。

具体表现：针对发送端发出的数据包序列号的确认应答信号ACK；针对数据包丢失或者出现定时器超时的重发机制；针对数据包到达接收端主机顺序乱掉的顺序控制；针对避免网络拥堵时候的流量控制；针对刚开始启动的时候避免一下子发送大量数据包而导致网络瘫痪的拥塞控制。

此外，TCP作为一种面向有连接的控制传输协议，只有在确认对端主机存在时才会发送数据，从而可以控制通信流量的浪费。

udp封装实现tcp:

UDP不提供复杂的控制机制，不提供可靠传输机制，是尽最大能力交付的。在传输过程中如果出现丢包，UDP也不负责重发，甚至当数据包的到达顺序乱掉之后也没有纠正顺序的功能。但具有资源消耗小，处理速度快的优点，所以通常音频、视频和普通数据在传送时使用UDP较多，因为它们即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。

如果需要这些细节控制的话，就需要在采用UDP协议的应用层去作出处理。在应用层模仿传输层TCP的可靠性传输。目前有开源程序利用udp实现了可靠的数据传输。如UDT（基于UDP的数据传输协议（UDP-basedData Transfer Protocol，简称UDT））

 

 

9.浏览器访问网站的一次完整过程？浏览器中输入一个URL发生什么，用到哪些协议？

 

1.DHCP 配置主机信息：

   如果主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。DHCP是基于UDP的，DHCP服务器是连接在交换机上的，不跨路由；在返回DHCP应答报文的时候经过交换机，用到了交换机的自学习能力。DHCP 配置了主机的IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。

2．DNS 解析域名

   浏览器中输入URL，首先浏览器要将URL解析为IP地址，解析域名就要用到DNS协议，首先主机会查询DNS的缓存，如果没有就给本地DNS发送查询请求。DNS查询分为两种方式，一种是递归查询，一种是迭代查询。如果是迭代查询，本地的DNS服务器，向根域名服务器发送查询请求，根域名服务器告知该域名的一级域名服务器，然后本地服务器给该一级域名服务器发送查询请求，然后依次类推直到查询到该域名的IP地址。

DNS服务器是基于UDP的。DNS协议是跨路由的（DNS服务器可能会在路由外）。域名解析过程会需要网关路由器的 MAC 地址，而DHCP过程中只知道网关路由器的IP地址，所以会用到ARP协议，解析IP地址得网关路由器的MAC地址（广播的方式）

 3. HTTP 请求页面

有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。

TCP的数据包会发送给IP层，用到IP协议。IP层通过路由选路，一跳一跳发送到目的地址。当然在一个网段内的寻址是通过以太网协议实现(也可以是其他物理层协议，比如PPP，SLIP)，以太网协议需要知道目的IP地址的物理地址（MAC地址），有需要ARP协议。

 

10.DDOS，怎么解决，如何让Server端收到ACK后再分配资源，不改变Client，不封装IP数据包？

DDOS ：SYN Flood是经典的DDoS攻击方式，SYN Flood攻击利用了TCP三次握手的缺陷，能够以较小代价使目标服务器无法响应。

TCP协议为了实现可靠传输，在三次握手的过程中设置了一些异常处理机制。第三步中如果服务器没有收到客户端的最终ACK确认报文，会一直处于SYN_RECV状态，将客户端IP加入等待列表，并重发第二步的SYN+ACK报文。重发一般进行3-5次，大约间隔30秒左右轮询一次等待列表重试所有客户端。另一方面，服务器在自己发出了SYN+ACK报文后，会预分配资源为即将建立的TCP连接储存信息做准备，这个资源在等待重试期间一直保留。更为重要的是，服务器资源有限，可以维护的SYN_RECV状态超过极限后就不再接受新的SYN报文，也就是拒绝新的TCP连接建立。

SYN Flood正是利用了上文中TCP协议的设定，达到攻击的目的。攻击者伪装大量的IP地址给服务器发送SYN报文，由于伪造的IP地址几乎不可能存在，也就几乎没有设备会给服务器返回任何应答了。因此，服务器将会维持一个庞大的等待列表，不停地重试发送SYN+ACK报文，同时占用着大量的资源无法释放。更为关键的是，被攻击服务器的SYN_RECV队列被恶意的数据包占满，不再接受新的SYN请求，合法用户无法完成三次握手建立起TCP连接。也就是说，这个服务器被SYN Flood拒绝服务了。

解决：修改内核参数：启用SYN Cookie；设置SYN最大队列长度；设置SYN+ACK最大重试次数；

启用SYN Cookie：SYN Cookie的作用是缓解服务器资源压力。启用之前，服务器在接到SYN数据包后，立即分配存储空间，并随机化一个数字作为SYN号发送SYN+ACK数据包。然后保存连接的状态信息等待客户端确认。启用SYN Cookie之后，服务器不再分配存储空间，而且通过基于时间种子的随机数算法设置一个SYN号，替代完全随机的SYN号。发送完SYN+ACK确认报文之后，清空资源不保存任何状态信息。直到服务器接到客户端的最终ACK包，通过Cookie检验算法鉴定是否与发出去的SYN+ACK报文序列号匹配，匹配则通过完成握手，失败则丢弃。

设置SYN最大队列长度是使用服务器的内存资源，换取更大的等待队列长度，让攻击数据包不至于占满所有连接而导致正常用户无法完成握手。

设置SYN+ACK最大重试次数是降低服务器SYN+ACK报文重试次数，尽快释放等待资源。

这三种措施与攻击的三种危害一一对应，完完全全地对症下药。但这些措施也是双刃剑，可能消耗服务器更多的内存资源，甚至影响正常用户建立TCP连接，需要评估服务器硬件资源和攻击大小谨慎设置。

 

11.blocking（默认）和nonblock模式下read/write行为的区别：

将socket fd设置为nonblock（非阻塞）是在服务器编程中常见的做法，采用blocking IO并为每一个client创建一个线程的模式开销巨大且可扩展性不佳（带来大量的切换开销），更为通用的做法是采用线程池+Nonblock I/O+Multiplexing（select/poll，以及Linux上特有的epoll）。

 结论：

1. read总是在接收缓冲区有数据时立即返回，而不是等到给定的read buffer填满时返回。只有当receive buffer为空时，blocking模式才会等待，而nonblock模式下会立即返回-1（errno = EAGAIN或EWOULDBLOCK）

2. blocking的write只有在缓冲区足以放下整个buffer时才返回（与blocking read并不相同）nonblock write则是返回能够放下的字节数，之后调用则返回-1（errno = EAGAIN或EWOULDBLOCK）

3.  对于blocking的write有个特例：当write正阻塞等待时对面关闭了socket，则write则会立即将剩余缓冲区填满并返回所写的字节数，再次调用则write失败。这是read/write对连接异常的一种反馈行为。

read/write对连接异常的反馈行为：

对应用程序来说，与另一进程的TCP通信其实是完全异步的过程：1. 我并不知道对面什么时候、能否收到我的数据也不知道什么时候能够收到对面的数据。2. 我不知道什么时候通信结束（主动退出或是异常退出、机器故障、网络故障等等）

对于1采用write() -> read() -> write() -> read() ->...的序列，通过blocking read或者nonblock read+轮询的方式，应用程序可以保证正确的处理流程。

对于2，kernel将这些事件的“通知”通过read/write的结果返回给应用层。

 

12.socket网络编程有哪些系统调用？

TCP客户：socket() ->connect()->write()->read()->close()

TCP服务器：socket()->bind()->listen()->accept()->fork()->read()/write()->close()

 

socket():

int socket(AF_INEF,SOCK_STREAM,0);//创建一个IPv4/ IPv6的TCP套接字。

 

connect()：客户用connect()建立与TCP服务器的连接。

int  connect(int sockfd,const struct sockaddr *seraddr,socklen_t  addrlen)

在创建套接字，用对端服务器的IP地址和端口号（通过main命令行参数指定）填充struct sockaddr之后。客户用connect()建立与TCP服务器的连接。

TCP连接的过程是由内核完成，connect()的作用仅仅是通知 Linux 内核，让 Linux 内核自动完成 TCP 三次握手连接. 连接的结果返回给这个函数的返回值（成功连接为0， 失败为-1）客户端的 connect() 函数默认会一直阻塞(在连接期间)，直到三次握手成功或超时失败才返回。

 

Connect()失败原因：1. TCP客户在多次连接请求分节后一直接受不到服务器对SYN分节的响应，则返回ETIMEOUT错误。

2.若对客户的SYN的响应是RST(表示复位)，则表明该服务器主机在我们指定的端口上没有进程在等待与之连接（服务器也许还没有运行）。这是一种硬错误

3.若客户的SYN在中间的某个路由器上引发一个路由不可达ICMP错误，客户主机内保存该消息，并重发SYN分节。

 

Connect()失败后套接字不可再用，必须关闭，不能再对这样的套接字调用Connect()重新连接请求。

 

bind()

int  bind(int sockfd,const struct sockaddr *seraddr,socklen_t  addrlen)

   bind()把填入到套接字地址结构中的本地协议地址（比如IP地址+TCP端口）赋予一个套接字.

   如果一个TCP客户或服务器未曾用bind（）捆绑一个端口，当调用Connect()或Listen（）时内核就为相应的套接字选择一个临时端口。客户端通常都是由内核就为相应的套接字选择一个临时端口。服务器端通常需要用bind()捆绑一个众所周知端口。

   进程可以把一个特定的IP地址绑定到它的套接字上，但是这个IP地址必须属于其所在主机的网络接口之一。对于TCP客户，就为该套接字上发送的数据报指派了源IP地址。对于TCP服务器，这就限制了该套接字只接受那些目的地址为指定IP地址的客户连接。TCP客户通常不把IP地址捆绑到它的套接字上。当连接套接字时内核将根据所用外出网络接口来选择源IP地址，所用外出接口取决于到达服务器所需的路径。如果TCP服务器没有吧IP地址捆绑到它的套接字上，内核就把客户发送的SYN的目的IP地址作为服务器的源IP地址。

 

Listen():

int Listen(int sockfd,int backlog) 

listen函数仅由服务器调用，它做两件事情：1.当socket函数创建一个套接字时，它被假设成一个主动套接字，是一个将调用connect发起连接的客户套接字。Listen函数把一个未连接的套接字转换成一个被动等待连接的监听套接字，指示内核应接受指向该套接字的连接请求。调用listen导致套接字从CLOSED状态转化为LISTEN转态。

2.本函数第二个参数backlog规定了内核应该为相应套接字队列的最大连接数目。

内核为一个监听套接字维护两个队列；

未完成连接队列：客户发送SYN请求分节，服务器接受后这些套接字处于SYN_RCVD状态，等待三次握手的完成。Listen函数不会阻塞。

已完成连接队列：每个已完成连接的客户对应其中的一项。套接字处于ESTABLISHED状态。两队列之和不超过backlog。

在三次握手建立连接的过程中，服务器收到客户端的连接请求分节SYN就在未完成连接队列中创建一项，当连接完成后，未完成连接的对应条目转移到已连接队列中。accept能够返回。

Ddos攻击原理和listen（）: .listen（）有一个队列，处理连接请求。在收到匿名IP发过来的SYN之后，会在listen队列中存放一个记录，但是队列容量是有限的，当这样的恶意请求过多的时候，listen队列里就塞满了这些无效的连接请求，然后装不下更多的连接记录了，所以就拒绝其他请求了。

 

accept ()

int accept (int sockfd, struct sockaddr *cliaddr,socklen_t * addrlen);

当进程调用accept时，已完成连接队列中的对头项将返回给进程，或者如果该项为空，那么进程将被投入睡眠，直到TCP在已连接队列中放入一项才唤醒它。

调用accept内核将已连接的对端进程（客户）的协议地址装填进地址结构中，利用值结果返回参数返回客户端的协议地址。

如果acccept成功，那么其返回值是由内核自动生成的一个全新套装字描述符，套接字绑定到装填了对端协议地址的套接字地址结构上。在accept中，它的第一个参数是监听套接字描述符，它的返回值为已连接套接字。

 监听套接字与已连接套接字：一个服务器通常只创建一个监听套接字，它在该服务器的生命周期内一直存在。内核为每个由服务器进程接受的客户连接创建一个已连接套接字。当服务器完成对某个给定的服务时，相应的已连接套接字就被关闭。

 

 

fork ()和exec()

pid_t fork (void);

fork()是进程创建的唯一方式。TCP中在父进程调用accept()获得一个已连接套接字，然后调用fork（）创建一个子进程，用来处理每个连接。父进程用来继续监听其他的客户连接。

父进程中调用fork之前打开的所有的描述符在fork返回之后，复制到子进程中由子进程共享。子进程关闭复制过来的监听套接字（此时父进程中的监听套接字并没有关闭），接着读写这个已连接套接字。父进程关闭已复制给子进程的已连接套接字。子进程中调用相应的函数处理客户的连接请求。

fork()的两个典型用法：1.一个进程创建自身的副本，这样每个副本都可以在另一个副本执行其他任务的同时处理各自的操作。这是网络服务器的典型用法。2.一个进程想要执行另一个程序。既然创建新进程的唯一办法是调用fork（），该进程于是首先调用fork()创建一个自身的副本，然后其中一个副本（通常是子进程）调用exec

把自身替换成新的程序。这是诸如shell之类程序的典型用法。

exec（）:

存放在硬盘上的可执行文件能够被Unix执行的唯一方法是：由一个现有进程调用6个exec中的某一个。exec把当前进程映象替换成新的程序文件，而且该新程序通常是从main函数开始执行。进程ID并不改变。

 

close()和shutdown()

close:  close一个套接字的默认行为是把该套接字标记成已关闭，然后立即返回到调用进程。该套接字描述符不能再由调用进程使用，也就是说它不能再作为read()和write()的第一个参数。然后TCP将尝试发送已排队等待发送到对端的任何数据，发送完毕后发生的是正常的TCP连接终止序列。

描述符引用计数：并发服务器中父进程关闭已连接套接字只是导致相应描述符的引用计数减1，如果仍然引用计数大于0，这个close调用并不会引发TCP终止序列。如果确实想在某个连接上发送一个FIN，而不管引用计数，可以改用shutdown函数代替close函数。

父进程对每个由accept返回的已连接套接字必须调用close,否则父进程最终将耗尽可用描述符。更重要的是，没有一个客户连接会被终止，因为当子进程关闭已连接套接字，它的引用计数将由2减到1，且保持为1，因为父进程永不关闭任何已连接套接字了，这将妨碍TCP终止序列的发生，导致连接一直打开着。

 

Shutdown: 

调用close终止TCP连接有两个限制：1。Close只是把套接字的引用计数减1，如果需要立刻关闭套接字，不管引用计数，可以改用shutdown函数代替close函数。

2.close一个套接字后，该套接字描述符不能再由调用进程使用，不能再作为read()和write()的第一个参数。即close同时终止读和写两个方向的数据传递。既然TCP连接是全双工的，那经常需要在不需要发送数据关闭发送这一端的时候仍然可以接收对方的数据。使用shutdown函数可以达到。

 

int shutdown(int sockfd, int howto)

shutdown函数的行为依赖于howto的值；

SHUT_WR 关闭连接的写这一半。对于TCP套接字这称为半关闭状态。当前留在套接字发送缓冲区中的数据将被发送，后跟TCP的正常终止序列。不管套接字的引用计数是否为0，这样的半关闭照样执行。进程不能再对这样的套接字调用任何函数。

SHUT_RD关闭连接的读这一半。套接字中不再有数据可以接收，而且套接字接收缓冲区现有的数据全部被丢弃。套接字接收的来自对端的任何数据都被确认，然后丢弃。进程不能载对这样的套接字调用任何函数。

 

getsockname()和getpeername()

返回与某个套接字关联的本地协议地址或者外地协议地址。

适用场景：

1.在一个没有调用bind的TCP客户上，connect成功返回后，getsockname()用于返回由内核赋予该连接的本地IP地址和本地端口号。

2.在以端口号0调用bind后(告知内核去选择本地端口号)，getsockname()用于返回由内核赋予的本地端口号。

3.getsockname()用于获取某个连接的地址族。

4.在一个以通配IP地址调用bind的TCP服务器上，与某个客户的连接一旦建立，(accept 成功返回)，getsockname()可以用于返回由内核赋予本连接的本地IP地址。

在这样的调用中，套接字描述符必须是已连接套接字描述符而不能是监听套接字描述符。

5. 当一个服务器程序是由调用过accept的某个进程通过exec执行程序时，它能够获取客户身份的唯一途径便是调用getpeername()。Inned超级服务器fork并exec某个服务器程序时就是如此情形。 

    Inned 调用accept返回已连接套接字描述符和客户的IP地址端口号。    Inned 随后调用fork,创建一个子进程，子进程起源于父进程的内存映像的一个副本，父进程中的那个套接字地址结构和已连接描述符都复制到子进程中，然后当子进程exec执行某个服务器程序时，子进程的内存映像就被替换成服务器程序文件，包含之前的对端地址的那个套接字地址结构就此丢失。此时调用getpeername()可以获得客户的IP地址和端口号。

   

read()和write()

   

write成功返回只是buf中的数据被复制到了kernel中的TCP发送缓冲区。至于数据什么时候被发往网络，什么时候被对方主机接收，什么时候被对方进程读取，系统调用层面不会给予任何保证和通知。

write在什么情况下会阻塞？

对于每个socket，拥有自己的send buffer和receive buffer,当kernel的该socket的发送缓冲区已满时,write会阻塞。

已经发送到网络的数据依然需要暂存在send buffer中，只有收到对方的ack后，kernel才从buffer中清除这一部分数据，为后续发送数据腾出空间。接收端将收到的数据暂存在receive buffer中，自动进行确认。但如果socket所在的进程不及时将数据从receive buffer中取出，最终导致receive buffer填满，由于TCP的滑动窗口和拥塞控制，接收端会阻止发送端向其发送数据。

一般来说，由于接收端进程从socket读数据的速度跟不上发送端进程向socket写数据的速度，最终导致发送端write调用阻塞。

read调用从socket的receive buffer中拷贝数据到应用程序的buffer中。read调用阻塞，通常是发送端的数据没有到达。

 

fork、vfork以及clone的区别，exec的作用
fork、vfork、clone是Linux用来创建新的进程（线程）而设计的。exec()系列函数则是用指定的程序替换当前进程的所有内容。exec()系列函数经常在前三个函数使用之后调用，来创建一个全新的程序运行环境。Linux用init进程启动其他进程的过程一般都是通过exec()系列函数实现的。fork、vfork、clone分别调用了sys_fork、sys_vfork、sys_clone，最终都调用了do_fork函数，差别在于参数的传递和一些基本的准备工作不同。可见这三者最终达到的最本质的目的都是创建一个新的进程。Linux内核中没有独立的“线程”结构，Linux的线程就是轻量级进程，线程的基本控制结构和Linux的进程是一样的（都是通过struct task_struct管理）。 

 fork是最简单的调用，不需要任何参数，仅仅是在创建一个子进程并为其创建一个独立于父进程的空间。fork使用COW（写时拷贝）机制，并且COW了父进程的栈空间。

vfork是一个过时的应用，vfork也是创建一个子进程，但是子进程共享父进程的空间。在vfork创建子进程之后，父进程阻塞，直到子进程执行了exec()或者exit()。vfork最初是因为fork没有实现COW机制，而很多情况下fork之后会紧接着exec，而exec的执行相当于之前fork复制的空间全部变成了无用功，所以设计了vfork。而现在fork使用了COW机制，唯一的代价仅仅是复制父进程页表的代价，所以vfork不应该出现在新的代码之中。

clone是Linux为创建线程设计的（虽然也可以用clone创建进程）。所以可以说clone是fork的升级版本，不仅可以创建进程或者线程，还可以指定创建新的命名空间（namespace）、有选择的继承父进程的内存、甚至可以将创建出来的进程变成父进程的兄弟进程等等。clone和fork的调用方式也很不相同，clone调用需要传入一个函数，该函数在子进程中执行。此外，clone和fork最大不同在于clone不再复制父进程的栈空间，而是自己创建一个新的。

 

循环fork，问有多少个输出行的题

 

总打印出来了6个A，因为我们是先fork后打印。所以，在第1次循环，第1次打印A的时候，已经有一个增生的进程了，所以第1次打印共打印出2个A。在第2次循环的时候，最开始的进程与增生的进程各自又增生了一个进程，所以当前共有4个进程，打印出来了4个A。共有6个A。

 

网络通信出故障如何排查，讲讲fiddler,tcpdump

使用tcpdump抓包，并用Wireshark和Fiddler工具分析。排查问题的时候，进程要遇到抓包，如果是在windows环境，可以使用wireshark直接抓包，如果是在linux环境下，可以使用tcpdump命令进行抓包，然后取下来用wireshark或者Fiddler进行分析。tcpdump也可以用来抓udp的包。

https://blog.csdn.net/u014209205/article/details/81104908

 

紧急指针

TCP仅支持一个字节的带外(OOB)紧急数据。

TCP报文首部的紧急指针(urgent pointer)指向该带外紧急数据偏移的下一字节。

如发送方欲发送多字节的带外紧急数据，其结果是：紧急指针指向最后一个数据偏移的下一字节，而之前所有数据被当作普通数据处理。

即：发送端只把提供数据的最后一个字节当作带外紧急数据；接收端只会接收到一个字节的带外紧急数据

 

如何监听tcp丢包问题。（细节知识点）。分析丢包原因

用tcpdump抓包分析可以发现tcp丢包问题，如：

 

 

网络丢包原因分析：

1. 网络链路阻塞引起丢包。数据在网络传输的过程中会经过很多设备和网路链接。只要其中一个网路链接在数据传输过来之前已经满负载了，那么数据将会在这里阻塞一段时间,然后在经过网络链路传送（这也就是所谓的排队）。 如果说网络设备非常落后于这个网路链接的话，那么网路链接没有足够给新数据来等待的空间，只能将信息丢掉，发生丢包。

解决：增加阻塞链接的带宽；

2.网络设备（路由器，交换机）性能不够。当大量网络数据包传送到达网络设备，但是此时网络设备的CPU，或者内存满载了，并没有能力来处理其他的数据包。这导致设备不能处理的数据包都被丢弃。

解决：必须更换吞吐量更大,性能更好的网络硬件,或者构建集群来提高吞吐量。

 

tcp粘包问题，怎么处理？udp会粘包吗？为什么？

TCP粘包问题：TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。粘包可能由发送方造成，也可能由接收方造成。TCP为提高传输效率，发送方往往要收集到足够多的数据后才发送一包数据，造成多个数据包的粘连。如果接收进程不及时接收数据，已收到的数据就放在系统接收缓冲区，用户进程读取数据时就可能同时读到多个数据包。因为系统传输的数据是带结构的数据，需要做分包处理。

方法一 是采用分隔符的方式，即我们在封装要传输的数据包的时候，采用固定的符号作为结尾符（数据中不能含结尾符），这样我们接收到数据后，如果出现结尾标识，即人为的将粘包分开，如果一个包中没有出现结尾符，认为出现了分包，则等待下个包中出现后 组合成一个完整的数据包，这种方式适合于文本传输的数据，如采用/r/n之类的分隔符；

方法二  是采用在数据包中添加长度的方式，即在数据包中的固定位置封装数据包的长度信息（或可计算数据包总长度的信息），服务器接收到数据后，先是解析包长度，然后根据包长度截取数据包（此种方式常出现于自定义协议中），但是有个小问题就是如果客户端第一个数据包数据长度封装的有错误，那么很可能就会导致后面接收到的所有数据包都解析出错（由于TCP建立连接后流式传输机制），只有客户端关闭连接后重新打开才可以消除此问题，我在处理这个问题的时候对数据长度做了校验，会适时的对接收到的有问题的包进行人为的丢弃处理（客户端有自动重发机制，故而在应用层不会导致数据的不完整性）；

方法三 不建议的方式是TCP采用短连接处理粘包（这个得根据需要来，所以不建议）；
TCP粘包处理-RingBuf方法：
    https://blog.csdn.net/liuchen1206/article/details/7075770

UDP不存在粘包问题，是由于UDP发送的时候，没有经过Negal算法优化，不会将多个小包合并一次发送出去。另外，在UDP协议的接收端，采用了链式结构来记录每一个到达的UDP包，这样接收端应用程序一次recv只能从socket接收缓冲区中读出一个数据包。也就是说，发送端send了几次，接收端必须recv几次（无论recv时指定了多大的缓冲区）。

 

在三次握手过程中第二条包丢了会怎么样？第三条丢了会怎样？有什么现象？

第二个ACK包丢了：客户端重发连接请求；

第三个ACK包丢了：客户端认为连接建立，写数据时，会触发RST。

 

服务器listen后不accept，客户端connect会返回吗。【可以，内核负责三次握手，维护一个已完成链接的队列，聊了一下已完成连接和未完成链接队列的问题】，



# c++后台开发面试常见知识点总结（三）操作系统
静态链接库和动态链接库的区别
一个进程可以通过调用waitpid函数来等待它的子进程终止或者停止
Debug和Release的区别
临界区互斥量信号量事件进程互斥与同步
进程有哪几种状态，状态转换图，及导致转换的事件
进程由运行态进入就绪态和阻塞态的原因
进程切换
进程调度算法
死锁
哲学家就餐问题
linux运行时内存映像
通过虚拟地址访问内存的优势
缓存是数据交换的缓冲区（称为Cache）
线程访问某数据
无名管道  FIFO（命名管道）消息队列信号量信号共享内存
1.    静态链接库和动态链接库的区别：

(1)       静态链接库在编译阶段链接，动态链接库库在加载和运行阶段链接。

(2)       在任何给定的文件系统中，只有动态链接库的一个副本，静态库的内容被复制和嵌入到引用它们的每一个执行文件中

(3)       在内存中，一个动态链接库的.text节的一个副本可以被不同的正在运行的进程共享；静态链接库的函数的代码会被复制到每个运行进程的代码段中。

(4)       如果想使用一个静态库的最新版本，必须显式地将程序与更新了的库重新链接；而如果想使用动态链接库最新版本只需要使用动态链接库的新版本替代当前的版本。

(5)       静态链接库中不能再包含其他的动态链接库或者静态库，而在动态链接库中还可以再包含其他的动态或静态链接库。

2.    进程和线程的区别：
 

(1)       进程是资源分配、调度的最小单位，线程是CPU调度的最小单位。

(2)       进程有自己的独立地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，这种操作非常昂贵。而线程是共享进程中的数据的，使用相同的地址空间，因此CPU切换一个线程的花费远比进程要小很多，同时创建一个线程的开销也比进程要小很多。

(3)       线程之间的通信更方便，同一进程下的线程共享全局变量、静态变量等数据，而进程之间的通信需要以进程间通信的方式（IPC）进行。不过如何处理好同步与互斥是编写多线程程序的难点。

(4)       多进程程序更健壮，多线程程序只要有一个线程死掉，整个进程也死掉了，而一个进程死掉并不会对另一个进程造成影响。

注：上述提到的资源包括可重用资源：处理器、I/O部件、内存、文件、数据库、信号量

可消耗资源：信号、中断、消息

3.    多进程和多线程的选择
(1)       需要频繁创建、销毁的选用多线程。

(2)       需要频繁切换的选用多线程

(3)       要求共享某些变量的选用多线程。

(4)       可能要扩展到多机分布的用多进程，多核分布的用多线程

(5)       强相关的处理用多进程，弱相关的用多线程。

4.    fork函数
子进程得到与父进程用户级虚拟地址空间相同（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本。

(1)       调用一次，返回两次。fork函数被父进程调用一次，但是却返回两次——一次是返回到父进程，一次是返回到新创建的子进程。在父进程中，fork返回子进程的PID。在子进程中，fork返回0

(2)       并发执行。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。

(3)       相同但是独立的地址空间。如果能够在fork函数在父进程和子进程返回后立即暂停这两个进程，我们会看到两个进程的地址空间都是相同的。每个进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。

(4)       共享文件。子进程继承了父进程所有的打开文件。

5.    一个进程可以通过调用waitpid函数来等待它的子进程终止或者停止。
6.    Debug和Release的区别
(1)       Debug：调试版本，包含调试信息，所以容量比Release版本大很多，并且不进行任何优化（优化会使调试复杂化，因为源代码和生成的指令间关系会更复杂），便于程序员调试。Debug模式下生成两个文件，除了.exe或.dll文件外，还有一个.pdb文件，该文件记录了代码中断点等调试信息。

(2)       Release：发布版本，不对源代码进行调试，编译时对应用程序进行优化，使得代码大小和运行速度上都是最优的。Release模式下生成一个文件.exe或.dll文件。

 

7.    编译语言和脚本语言的区别
（1）脚本语言语法简单，比较容易掌握；编译语言具有严谨，复杂语法。

（2）脚本语言在运行时被解释器解释成指令后立即被执行；编译语言被编译成可执行目标文件后被执行。

（3）因此，脚本语言不需编译，但运行速度慢；编译语言需要编译，运行速度较快。

8.    线程安全
(1)       线程安全就是多线程访问时，采用了加锁机制（同步互斥机制），当一个线程访问该类的某个数据时，进行保护，其他线程不能进行访问直到该线程访问结束，其他线程才可使用。不会出现数据不一致或者数据污染。

(2)       线程不安全就是不提供数据访问保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。

注：怎么判断线程安全：多线程编程中，对类的对象的操作不需要使用额外的同步机制，也能保证对象不会处于无效状态。

9.    临界区
用于解决互斥问题。临界区保证同一时刻只有一个线程可以访问被保护起来的资源或代码段，所有其他试图访问被保护起来的资源或代码段的线程将被挂起，并一直持续到当前正在访问被保护起来的资源或代码段的线程访问完毕。临界区对象被释放后，其他线程可以继续抢占临界区对象的使用。

特点：临界区不是内核对象，不能够用于进程之间的互斥，但临界区更节省资源更有效率。

 

 

10. 互斥量
用于解决互斥问题。互斥量允许同一时刻只有一个进程访问互斥资源，所有其他试图访问互斥资源的进程将被挂起，并一直持续到访问互斥资源的线程访问完毕。互斥量被释放后，其他线程可以继续抢占互斥资源的使用。

 

 

11. 信号量
信号量是进程间同步、互斥的一种机制。信号量允许多个进程访问共享资源，但对同一时刻访问共享资源的进程的数目的上限有要求。

注：

（1）在信号量上定义了三个操作：初始化、P操作、V操作

（2）P、V操作为原语操作

（3）信号量可分为二元信号量，用于解决互斥问题；多值信号量，用于解决同步问题

 

12. 事件
事件机制，允许一个线程在处理完一个任务后，主动唤醒另一个线程执行任务。

自动事件：当一个事件得到通知时，等待该事件的线程只有一个线程变为可调度线程。

人工事件：当一个事件得到通知时，等待该事件的所有线程均变成可调度线程。

13. 进程互斥与同步
（1）进程互斥：各进程之间竞争使用互斥资源，这一关系称为进程互斥。

（2）进程同步：指系统中多个进程中发生的事件存在某种时序关系，需要相互合作，共同完成一项任务。

14. 进程有哪几种状态，状态转换图，及导致转换的事件
 

运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。

就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。

阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。

就绪状态 -> 运行状态：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。

运行状态 -> 就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。

运行状态 -> 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。

阻塞状态 -> 就绪状态：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。

15. 进程由运行态进入就绪态和阻塞态的原因
（1）时间片用完

（2）在可抢占的操作系统中，有更高优先级的进程就绪

（3）进程请求某一资源的使用和分配

（4）进程等待某一个时间的发生（如I/O操作完成）

（5）进程需要和其他进程保持同步

（6）进程运行完毕

（7）在不可抢占的操作系统中，进程由核心态转入用户态时系统产生一次调度，将最高优先权的就绪进程投入运行。

16. 进程切换
进程切换主要包括两部分工作：

（1）切换全局目录以加载一个新的地址空间

（2）切换内核栈和硬件上下文，其中硬件上下文包括了内核执行新进程需要的全部信息，如CPU相关寄存器（程序计数器、程序状态寄存器）

注：切换过程包括了对原来运行进程各种状态的保存和对新的进程各种状态的恢复。

17. 进程调度算法
(1)       批处理系统中采用的调度算法：

①　先来先服务（FCFS）：按进程就绪的先后顺序使用CPU（非抢占式）

优缺点：公平、实现简单、长进程后面的短进程需要等待很长时间，不利用用户体验

②　最短作业优先（SJF）：具有最短完成时间的进程优先执行（非抢占式）

思路：先完成短的作业，改善短作业的周转时间

优缺点：

最短的平均周转时间：在所有进程同时可运行时，采用SJF调度算法可以得到最短的平均周转时间

不公平：源源不断的短任务到来，可能使长的任务长时间得不到运行->产生“饥饿”现象

③　最短路径剩余空间时间优先（SRTN）（抢占式）

④　最高响应比优先：是一个综合的算法，调度时，首先计算每个进程的响应比R；之后，总是选择R最高的进程执行；折中权衡。

响应比R=周转时间/处理时间=（处理时间+等待时间）/处理时间=1+（等待时间/处理时间）

(2)       交互式系统中采用的调度算法

①　时间片轮转

目标：为短任务改善平均响应时间

解决问题的思路：周期性切换；每个进程分配一个时间片；时钟中->轮换

时间片太长：降级为先来先服务算法；延长短作业的响应时间

时间片太短：进程频繁切换浪费CPU时间

优缺点：公平；有利于交互式计算，响应时间快；由于进程频繁切换，时间片轮转算法要花费较高的开销用于进程的切换。

②　最高优先级调度：选择优先级最高的进程投入运行

③　多级反馈队列

设置多个就绪队列，第一级队列优先级最高。

给不同就绪队列中的进程分配长度不同时间片，第一级队列时间片最小；

随着队列优先级别的降低，时间片增大；

当第一级队列为空时，在第二级别队列调度，以此类推

各级队列按照时间片轮状方式进程调度

当一个新创建进程就绪后，进入第一级队列

进程用完时间片而放弃CPU，进入下一级就绪队列

由于阻塞而放弃CPU进入想用的等待队列，一旦等待队列发生，该进程回到原来一级就绪队列。

④　最短进程优先

 

 

18. 典型系统所采用的调度算法
Unix：

Windows：基于优先级的抢占式多任务调度

Linux：抢占式调度

 

19. 大端模式和小端模式
大端模式，是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中

小端模式，是指数据的低字节保存在数据的低地址中，数据的高字节保存在数据的高地址中。

20. 死锁的概念
一组进程中，每个进程都无限等待被该组进程中的另一个进程所占有的资源，这种现象称为进程死锁，这一组进程被称为死锁进程。

21. 死锁、活锁和饥饿
（1）死锁：

（2）活锁：先加锁，在轮询，不断轮询，既无进展也没有阻塞

（3）饥饿：持续有其他的优先级更高的进程请求相同的资源，所申请的资源一直得不到满足。饥饿现象是由资源分配策略决定的。

22. 产生死锁的必要条件
（1）互斥使用

一个资源每次只能给一个进程使用

（2）占有且等待

进程在申请新的资源的同时保持对原有资源的占有

（3）不可抢占

资源的申请者不能强行的从资源占有者手中夺取资源，资源只能由占有者自愿释放。

（4）循环等待

存在一个进程等待队列{P1，P2，...,P3}，

其中P1等待P2占有的资源，P2等待P3占有的资源，...，Pn等待P1占有的资源，形成一个进程等待环路。

23. 死锁定理
（1）如果资源分配图中没有环路，则系统中没有死锁，如果图中存在环路则系统中可能存在死锁。

（2）如果每个资源类中只包含一个资源实例，则环路是死锁存在的充分必要条件。

24. 解决死锁的方法
（1）死锁预防

静态策略：设计合适的资源分配算法，不让死锁发生。

（2）死锁避免

动态策略：以不让死锁发生为目标，跟踪并评估资源分配过程，根据评估结果决策是否分配

（3）让死锁发生

死锁检测与解除

25. 死锁预防
在设计系统时，通过确定资源分配算法，排除死锁发生的可能性

（1）破坏“互斥使用/资源独占”条件

资源转换技术：把独占资源变为共享资源

spoing技术的引入

（2）破坏“占有且等待”条件

实现方案1：要求每个进程在运行前必须一次性申请它要求的所有资源，且仅当该进程所要资源均可满足时才给予一次性分配。

问题：资源利用率低；“饥饿”现象

实现方案2：在允许进程动态申请资源前提下规定，一个进程在申请新的资源不能立即得到满足而变为等待状态之前，必须释放已占有的全部资源，若需要再重新申请。

（3）破坏“不可抢占”条件

当一个进程申请的资源被其他进程占用时，可以通过操作系统抢占这一资源（两个进程的优先级不同）

局限性：适用于状态易于保存和恢复的资源（CPU、内存）

（4）破坏“循环等待”条件

资源的有序分配法：把系统中所有资源编号，进程在申请资源时必须严格按资源编号的递增次序进程，否则操作系统不予分配。

26. 死锁避免
在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁

27. 安全状态
安全状态：如果系统中存在一个由所有进程构成的安全序列P1，...，Pn，则称系统处于安全状态。

安全序列：一个进程序列{P1，...，Pn}是安全地，如果对于没一个进程pi（1<=i<=n）；它以后还需要的资源量不超过系统当前剩余资源量与所有进程pi（j<i）当前占有资源量之和。

28. 死锁的检测与解除
允许死锁的发生，但是操作系统不断检测死锁是否真的发生。

一旦死锁发生则采取专门的措施，解除死锁并以最小的代价恢复操作系统运行。

29. 死锁解除的办法：
（1）撤销所有的死锁进程

（2）按照某种原则逐一地撤销死锁进程

（3）进程回退再启动

（4）按照某种原则逐一抢占资源（资源被抢占的进程必须回退到之前的对应状态）

30. 哲学家就餐问题
（1）最多允许4个哲学家同时坐在桌子周围（死锁预防）

（2）仅当一个哲学家左右两边的筷子都可用时，才允许它拿筷子（死锁避免）

（3）给所有哲学家编号，奇数好的哲学家必须首先拿左边的筷子，偶数号的哲学家则反之

31. 堆和栈的区别
（1）管理方式：栈中的空间由编译器自动分配和释放，堆中的空间由程序显式地释放和分配

（2）存储内容：栈中存储函数的参数值和局部变量；对中存储动态对象

（3）空间大小：在Windows下，栈是向低地址扩展的数据结构，是一块连续的内存的区域。栈的最大容量是系统预先规定好的，在Windows下，栈的大小是2M因此，能从栈获得的空间较小；堆是向高地址扩展的数据结构，是不连续的内存区域。堆的大小受限于计算机系统中有效的虚拟内存。能从堆获得的空间较大。

（4）分配效率：栈由操作系统自动分配和释放，（计算机在底层对栈提供支持）栈的分配效率比较高；堆的分配由C/C+函数库提供，机制复杂，堆的分配效率要比栈低很多。

（5）碎片问题：对于堆来说，频繁的new/delete操作势必会造成内存空间的不连续，从而造成大量的碎片；栈不会产生空间碎片。

32. linux运行时内存映像
 

33. 一个源程序到可执行目标文件的过程
 

（1）预处理阶段：预处理器（cpp）根据以字符#开头的命令，修改原始的C程序。

（2）编译阶段：编译器（ccl）将文本文件hello.i翻译成文本文件hello.s，它包含一个汇编语言程序

（3）汇编阶段：汇编器（as）将一个hello.s翻译成机器语言指令，把这些指令打包成一个叫做可重定位目标程序的格式，并把结果保存在目标文件hello.o中。Hello.o文件是一个二进制文件。

（4）链接阶段：生成可执行目标文件。

34. 虚拟内存
虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存，而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。目前，大多数操作系统都使用了虚拟内存。

虚拟内存别称虚拟存储器。电脑中所运行的程序均需经由内存执行，若当前正在执行的程序占用内存很大或很多，则会导致内存消耗殆尽，为了解决该问题。Windows中运用了虚拟内存技术，即匀出一部分硬盘空间来充当内存使用。当内存耗尽时，电脑就会自动调用硬盘来充当内存，以缓解内存的紧张。

35. 通过虚拟地址访问内存的优势
（1）程序可以使用一系列相邻的虚拟地址空间来访问物理内存中不相邻的内存缓冲区

（2）程序可以使用一系列虚拟地址来访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页（通常大小为4KB）保存到磁盘文件。数据和代码页会根据需要在物理内存与磁盘之间移动。

（3）每个进程拥有独立的虚拟地址空间，一个进程的代码无法更改正在由另一个进程或操作系统使用的物理内存。因此，可以避免一个进程无意间破坏另一个进程所使用的物理内存中内容。

36. 缓存：
缓存是数据交换的缓冲区（称为Cache），当某一个硬件要读取数据时，会首先从缓存中查找需要的数据，如果找到了则直接执行，找不到的话则从内存中找。由于缓存的运行速度比内存的运行速度比内存快得多，故缓存的作用就是帮助硬件更快的运行。

37. 如何实现地址映射
Win32通过两层的表结构实现地址隐射：

第一层为页目录表（4KB大小）：分为1024个页目录项，每个页目录项对于一个页表

第二层为页表（4KB大小）：分为1024个页表项，每个页表项对应一个内存页，通过有4KB大小

32位地址：前10位为页目录下标，用来寻址页目录项，中间10位为页表下标，用来寻址内存页，后12位用来在物理内存页中找到对应的字节

 

38. 线程访问某数据
 

39. 缓存调度：
 

 

40. 缓存调度方法：
（1）FIFO

（2）LRU：最近最少使用

（3）LFU：最近使用次数最少

41. LRU实现
核心思想：“如果数据最近被访问过，那么将来被访问的几率也更高”

 

（1）新加入的数据插入到链表头部

（2）数据被访问，将数据移动到链表头部

（3）当链表满，将链表尾部的数据丢弃

 

 

42. LFU实现
“如果数据过去被访问多次，那么将来被访问的频率也更高”

 

（1）新加入的

43. 无名管道
管道：通常指无名管道，是UNIX系统IPC最古老的形式。
两个局限性：

（1）单向通信

（2）只能用于具有亲缘关系的进程之间

其他特点：

（3）管道的生命周期随着进程终止而结束

（4）它可以看成是一种特殊的文件，对于它的读写也可以使用普通的read、write等函数。但是它不是普通的文件，并不属于其他任何文件系统，并且只存在于内存中

 

44. FIFO（命名管道）
FIFO，也称为命名管道，它是一种文件类型

FIFO的特点：

（1）它提供一个路径名与之关联，以FIFO的文件形式存储于文件系统中

（2）FIFO可以用于无亲缘关系的进程之间的通信

（3）按照先进先出的方式工作

45. 消息队列
消息队列，是消息的的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识

（1）消息队列是基于消息的（管道是基于字节流的），其中的消息具有特定的格式以及特定的优先级

（2）消息队列独立于发送和接收进程。进程终止时，消息队列内容不会被删除

（3）消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取

注:

消息队列：对于每一个正在执行的Windows应用程序，系统为其建立一个“消息队列”，用来存放可能创建的各种窗口的消息。

消息循环：应用程序中含有一段称作“消息循环”的代码，用来从消息队列中检索这些消息并把它们分发到相应的窗口函数。

46. 信号量
信号量是进程间同步、互斥的一种机制。信号量允许多个进程访问共享资源，但对访问共享资源的进程的数目的上限有要求。

注：

（1）在信号量上定义了三个操作：初始化、P操作、V操作

（2）P、V操作为原语操作

（3）信号量可分为二元信号量，用于解决互斥问题；多值信号量，用于解决同步问题

 

47. 信号
一个信号就是一个小消息，信号用于通知接受进程发生了某种类型的事件。信号是在软件层次上对中断机制的一种模拟。

注：

（1）发送信号

（2）接受信号

（3）处理信号（阻塞信号、执行默认行为、执行信号处理程序）

48. 共享内存
共享内存，指两个或多个进程共享一个给定的存储区

特点：

（1）共享内存是最快的一种IPC

对于像管道和消息队列等进程间通信方式，需要在内核和用户空间进行四次的数据拷贝，而共享内存则只需要拷贝两次：一次从输入文件到共享内存区，另一个送共享内存到输出文件

（2）需要同步机制，以协调对共享内存的访问

注：

（1）

（2）进程之间通过映射同一个普通文件实现共享内存，共享内存中的内容往往是在解除映射时才写回文件

49. 套接字
与其他通信机制不同的是，它可用于不同主机的进程间的通信。

50. RPC
用于像调用本地过程一样调用远程过程

51. 僵尸进程、孤儿进程、守护进程
（1）僵尸进程：一个终止了但还未被回收的进程称为僵死进程。

注：shell或者服务器，总是应该回收它们的僵死子进程。即使僵死子进程没有运行，它们仍然消耗系统的内存资源，进程号也会被一直占用。

（2）孤儿进程：父进程执行完成或被终止后仍继续运行的一类进程。这些孤儿进程将被init进程所收养，并由init进程对它们完成状态收集工作。

（3）守护进程：守护进程是一类在后台运行的特殊进程，用于执行特定的系统任务。很多守护进程在系统引导的时候启动，并且一直运行直到系统关闭。另一些只在需要的时候才启动，完成任务后就自动结束。

52. 用户态和内核态
内核态：CPU可以访问内存中所有的数据，包括外设，例如硬盘、网卡，CPU也可以将自已从一个程序切换到另一个程序。

用户态：只能受限的访问内存，且不允许访问外设，占用CPU的时间可以被抢占。

https://www.cnblogs.com/zemliu/p/3695503.html

53. 消息
消息，就是windows发出的一个通知，告诉应用程序某个事件发生了。例如，单击鼠标、改变窗口尺寸、按下键盘上的一个键都会使windows发送一个消息给应用程序。

注：消息本身是作为一个记录（结构体）传递给应用程序的。

54. Windows的消息系统3个组成部分
（1）消息队列：对于每一个正在执行的Windows应用程序，系统为其建立一个“消息队列”，用来存放可能创建的各种窗口的消息。

（2）消息循环：应用程序中含有一段称作“消息循环”的代码，用来从消息队列中检索这些消息并把它们分发到相应的窗口函数。

（3）窗口过程：每个窗口都有一个窗口过程，即一个回调函数，来接收、处理传递给窗口的消息。处理了一个消息后，它通常要返回一个值给windows。

55.一个消息从产生到被一个窗口响应的过程
（1）系统中发生了某个事件。

（2）Windows把这个事件翻译为消息，然后把它放在消息队列中。

（3）应用程序从消息队列中接收到这个消息。

（4）应用程序把消息传递给一个适当的窗口的窗口过程。

（5）窗口过程响应这个消息并进行处理。

 

 

56.SendMessage和PostMessage
（1）PostMessage函数只是向线程消息队列中添加消息，如果添加成功，则返回true，否则返回false，消息是否被处理，或处理的结果，就不知道了。

（2）SendMessage则有些不同，当线程向自己发送消息时，它并不是把消息加到队列里，而是直接翻译消息和调用消息处理，知道消息处理完成后才返回。所以，如果我们希望发送的消息立即被执行，就应该调用SendMessage。

（3）线程向自己发送消息时，SendMessage发送的消息不会被加入到消息队列中，因此，不能通过PeekMessage或GetMessage获取SendMessage发送的消息。

（4）有些消息用PostMessage不会成功。所以不是所有的消息都能够用PostMessage。

57.为什么要用协程（进程和线程的痛点）
多线程程序设计到：

（1）锁机制

（2）设计到线程阻塞状态到可运行状态之间的切换

（3）设计到线程上下文的切换

以上涉及到的任何一点，开销都非常大的。

58. 什么是协程
协程，是一种比线程更加轻量级的存在。正如一个进程可以拥有多个线程一样，一个线程也可以拥有多个协程。更重要的是，协程不是被操作系统内核所管理，而完全是由程序所控制。



# c++后台开发面试常见知识点总结（四）数据库
数据库的索引类型
聚集索引和非聚集索引的区别（叶节点存储内容）
唯一性索引和主码索引的区别
索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）
索引最左前缀问题
数据库中事务的ACID
数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）
Mysql有四个隔离级别：未提交读，提交读，可重复读，可串行化。
Mysql的优化（高频，索引优化，性能优化）
数据库引擎介绍，innodb和myisam的特点与区别
数据库连接池的作用
讲讲你用过的所有锁，除了互斥锁与读写锁比如自旋锁，递归锁，乐观锁，悲观锁
两段锁协议
关系型和非关系型数据库的区别（各自优点）
数据库的范式
Mysql的表空间方式，各自特点。
分布式事务
视图的作用与使用方法（如何删除等）
分库分表，主从复制，读写分离。（我不会，也没碰到过）
memcache中的数据结构是如何实现的
memcache,redis内部存储数据原理
（1） 数据库的索引类型

索引是在存储引擎层实现的，不同存储引擎具有不同的索引类型和实现。

B+Tree索引 ：索引是大多数 MySQL 存储引擎的默认索引类型。如InnoDB 引擎和MyISAM 存储引擎。

哈希索引：InnoDB 引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。哈希索引能以 O(1) 时间进行查找，但是失去了有序性，它具有以下限制：1.无法用于排序与分组；2.只支持精确查找，无法用于部分查找和范围查找。

全文索引：MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。查找条件使用 MATCH AGAINST，而不是普通的 WHERE。全文索引一般使用倒排索引实现，它记录着关键词到其所在文档的映射。InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。

空间数据索引（R-Tree）：MyISAM 存储引擎支持空间数据索引，可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。

必须使用 GIS 相关的函数来维护数据。

（2） 聚集索引和非聚集索引的区别（叶节点存储内容）

聚集索引：InnoDB主索引是聚簇索引，在索引中保存了数据，数据库的表是通过主索引组织起来的，B+树的叶节点的数据域存储的完整的数据记录。一个表只能有一个聚簇索引。

辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。通常默认以自动递增的值为主索引的主键，而不是以一个唯一的列作为主键。以唯一的列作为主键会造成在插入新记录时数据文件为了维持B+Tree的特性而频繁的分裂调整，十分低效，而使用自增字段作为主键则是一个很好的选择。

非聚集索引：MyISAM提供的是非聚集索引。MyISAM主索引和辅助索引都是非聚集索引。B+树的叶节点，存储的是指向记录的指针。


（3） 唯一性索引和主码索引的区别

主键约束比唯一索引约束严格，当没有设定主键时，非空唯一索引自动称为主键。对于主键和唯一索引的一些区别主要如下：1.主键不允许空值，唯一索引允许空值。2.主键只允许一个，唯一索引允许多个。 3.主键产生唯一的聚集索引，唯一索引产生唯一的非聚集索引。

在使用InnoDB存储引擎时，如果没有特别的需要，请永远使用一个与业务无关的自增字段作为主键。而不是选择使用如学号或身份证号这种唯一字段作为主键。

创建唯一索引的目的往往不是为了提高访问速度，而只是为了避免数据出现重复。

（4）索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）

索引虽然加快了查询速度，但索引也是有代价的：索引文件本身要消耗存储空间，同时索引会加重插入、删除和修改记录时的负担，另外，MySQL在运行时也要消耗资源维护索引，因此索引并不是越多越好。一般两种情况下不建议建索引。

第一种情况是表记录比较少，没必要建索引，让查询做全表扫描就好了。通常记录数不超过 2000可以考虑不建索引，超过2000条可以酌情考虑索引。

另一种不建议建索引的情况是索引的选择性较低。（索引的选择性）


（5） 索引最左前缀问题

当按照索引中所有列进行精确匹配（这里精确匹配指“=”或“IN”匹配）时，索引可以被用到。

当查询条件精确匹配索引的左边连续一个或几个列时，只能用到一部分索引，即条件所组成的最左前缀。


（6）数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）

原子性：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。回滚可以用日志来实现，日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

一致性：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。

隔离性：一个事务所做的修改在最终提交以前，对其它事务是不可见的。

持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。可以通过数据库备份和恢复来实现，在系统发生奔溃时，使用备份的数据库进行数据恢复。

事务的 ACID 特性之间不是一种一种平级关系：

只有满足一致性，事务的执行结果才是正确的。
在无并发的情况下，事务串行执行，隔离性一定能够满足。此时要只要能满足原子性，就一定能满足一致性。
在并发的情况下，多个事务并发执行，事务不仅要满足原子性，还需要满足隔离性，才能满足一致性。
事务满足持久化是为了能应对数据库奔溃的情况。
MySQL 默认采用自动提交模式。也就是说，如果不显式使用START TRANSACTION语句来开始一个事务，那么每个查询都会被当做一个事务自动提交。

在并发的情况下，事务的隔离性不能实现时，就会出现脏读，不可重复读，丢失修改，幻影读等问题。

 

（7） 数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）

丢失修改：T1 和 T2 两个事务都对一个数据进行修改，T1 先修改，T2 随后修改，T2 的修改覆盖了 T1 的修改。则T1丢失修改。可在T1修改时对数据加上X锁，直到T1结束锁释放，在此期间T2不可修改该数据。

脏读：事务T1在修改数据a后，未commit。事务T2读取数据a,随后T1 rollback

撤销修改，则T2读到的数据a为脏数据。提交读隔离级别解决脏读问题。

不可重复读：同一个事务中多次读取同样数据的结果不一样。T2 读取一个数据，T1 对该数据做了修改。如果 T2 再次读取这个数据，此时读取的结果和第一次读取的结果不同。可在T2读取数据时对数据加上S锁，直到T2结束锁释放，在此期间T1不可修改该数据。可重复读隔离级别解决了不可重复读的问题。 

幻读：T1 读取某个范围的数据，T2 在这个范围内插入新的数据，T1 再次读取这个范围的数据，此时读取的结果和和第一次读取的结果不同。同上，同样可以加S锁解决该问题。

 MySQL 的 InnoDB 存储引擎，在可重复读（REPEATABLE READ）隔离级别下，使用 MVCC + Next-Key Locks 可以解决幻读问题。


（8） 数据库的隔离级别，mysql和Oracle的隔离级别分别是什么

Mysql有四个隔离级别：未提交读，提交读，可重复读，可串行化。

未提交读：事务中的修改，即使没有提交，对其它事务也是可见的。总是读取最新的数据行即是未提交读隔离级别。

提交读：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。

可重复读：保证在同一个事务中多次读取同样数据的结果是一样的。MVCC（多版本并发控制）实现提交读和可重复读这两种隔离级别。

 

可串行化：强制事务串行执行。遵循两段锁协议实现可串行化。

（9） Mysql的优化（高频，索引优化，性能优化）

查询优化：写SQL语句时，可以先select再JOIN，尽量把一元操作（select）往树叶上压，从而减小二元操作的规模。

 

索引优化：在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。

让选择性最强的索引列放在前面，索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。

对于 类似VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。对于前缀长度的选取需要根据索引选择性来确定。


（10） 数据库引擎介绍，innodb和myisam的特点与区别。

Innodb：InnoDB 是 MySQL 默认的事务型存储引擎，只有在需要 InnoDB 不支持的特性时，才考虑使用其它存储引擎。实现了四个标准的隔离级别，默认级别是可重复读。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（next-key locking）防止幻影读。主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

Myisam：MyISAM 提供了大量的特性，包括压缩表、空间数据索引等。不支持事务。不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入。

比较

事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。

并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。

外键：InnoDB 支持外键。

崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。

备份：InnoDB 支持在线热备份。

其它特性：MyISAM 支持压缩表和空间数据索引。

 

（11）数据库连接池的作用

什么是数据库连接池：创建数据库连接是一个很耗时的操作，也容易对数据库造成安全隐患。所以，在程序初始化的时候，集中创建多个数据库连接，并把他们集中管理，供程序使用，可以保证较快的数据库读写速度，还更加安全可靠。数据库连接池负责分配,管理和释放数据库连接,它允许应用程序重复使用一个现有的数据库连接,而不是重新建立一个。连接池必须要确保某一时间内一个 conn 只能分配给一个线程。不同 conn 的事务是相互独立的。

 

Java应用程序以传统的连接机制访问数据库的过程：①装载数据库驱动程序；②通过JDBC建立数据库连接；③访问数据库，执行SQL语句；④断开数据库连接。

使用了数据库连接池的机制：①程序初始化时创建连接池。②使用时向连接池申请可用连接③使用完毕，将连接返还给连接池。④程序退出时，断开所有连接，并释放资源。

 

（12）讲讲你用过的所有锁，除了互斥锁与读写锁比如自旋锁，递归锁，乐观锁，悲观锁

1.共享锁（又称读锁）、排它锁（又称写锁）：

InnoDB引擎的锁机制：InnoDB支持事务，支持行锁和表锁用的比较多，Myisam不支持事务，只支持表锁。

 共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。

排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

意向共享锁（IS）：事务打算给数据行加行共享锁，事务在给一个数据行加共享锁前必须先取得该表的IS锁。

意向排他锁（IX）：事务打算给数据行加行排他锁，事务在给一个数据行加排他锁前必须先取得该表的IX锁。

2.乐观锁、悲观锁：

悲观锁：悲观锁，正如其名，它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制（也只有数据库层提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统中实现了加锁机制，也无法保证外部系统不会修改数据）

乐观锁：

乐观锁（ Optimistic Locking ） 相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做（一般是回滚事务）。那么我们如何实现乐观锁呢，一般来说有以下2种方式：

 （13）两段锁协议

加锁和解锁分为两个阶段进行。事务遵循两段锁协议是保证可串行化调度的充分条件。

（充分非必要，遵循一定保证可串行化，不遵循也可能会串行化）可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。

（14） 关系型和非关系型数据库的区别（各自优点）

 （15）数据库的范式

不符合范式的关系（表），会产生很多异常，范式理论是为了解决异常。常见的异常有冗余数据，修改异常，删除异常，插入异常。高级别范式的依赖于低级别的范式，1NF 是最低级别的范式。

1NF：属性不可分。不满足1NF不是一个合法的关系表。

2NF：每个非主属性完全函数依赖于键码。不满足2NF可能会出现上述4种异常。可以通过分解表来满足。

3NF：非主属性不传递函数依赖于键码。不满足3NF可能会出现上述4种异常。可以通过分解表来满足。

 

两段锁协议

加锁和解锁分为两个阶段进行。事务遵循两段锁协议是保证可串行化调度的充分条件。

（充分非必要，遵循一定保证可串行化，不遵循也可能会串行化）

 

可串行化调度是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。


 Mysql的表空间方式，各自特点。

innodb引擎使Mysql有共享表空间和独占表空间两种数据存储方式。

 

共享表空间: 一个数据库的所有的表数据，索引数据共享一个表空间。多个表及索引在表空间中混合存储。

优点：可以把表空间分成多个文件存放到各个磁盘上，一个表可以分布在不同步的文件上。

表空间可以分成多个文件存放到各个磁盘，所以表也就可以分成多个文件存放在磁盘上，表的大小不受文件，磁盘大小的限制。数据和文件放在一起方便管理。

缺点：多个表及索引在表空间中混合存储，当一个表做了大量删除操作后表空间中将会有大量的空隙。共享表空间大小不会收缩。

 

独立表空间：每个表都有自已独立的表空间。每个表的数据和索引都会存在自已的表空间中。

其它信息如，回滚(undo)信息、仍放在默认表空间。默认表空间不会收缩空间。

优点：可以实现单表在不同的数据库中移动。 对于使用独立表空间的表，不管怎么删除，表空间的碎片不会太严重的影响性能，而且还有机会处理。独立表空间大小可以收缩。

缺点：单表增加过大，如超过100个G。

总结：相比较之下，使用独占表空间的效率以及性能会更高一点。共享表空间以及独占表空间之间的转化可以通过在配置文件中设置innodb_file_per_table参数实现。为OFF说明所使用的是独占表空间。


（18） 分布式事务

一次大的操作由不同的小操作组成，这些小的操作分布在不同的服务器上，且属于不同的应用，分布式事务需要保证这些小操作要么全部成功，要么全部失败。本质上来说，分布式事务就是为了保证不同数据库的数据一致性。

（21） 视图的作用与使用方法（如何删除等）

视图是虚拟的表，对视图的操作和对普通表的操作一样。但视图本身不包含数据，也就不能对其进行索引操作。视图具有如下好处：1.通过只给用户访问视图的权限，保证数据的安全性；2.简化复杂的 SQL 操作，比如复杂的连接；3. 更改数据格式和表示；4. 只使用实际表的一部分数据；

CREATE VIEW myview AS

SELECT Concat(col1, col2) AS concat_col, col3*col4 AS compute_col

FROM mytable

WHERE col5 = val;

总结：视图包含的不是表的数据，是对select查询的封装。可以简化数据处理，重新格式化基础数据。

（22） 分库分表，主从复制，读写分离。（我不会，也没碰到过）

分库分表：

水平切分：又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。事务：使用分布式事务来解决事务问题。JOIN：可以将原来的 JOIN 查询分解成多个单表查询，然后在用户程序中进行 JOIN。

 

memcache中的数据结构是如何实现的

memcache是分布式缓存服务器，通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。memcache中保存的数据都存储在memcache内置的内存存储空间中。重启memcache、操作系统都会导致全部数据消失。当memcache内容容量达到指定值之后，memcache就基于LRU算法淘汰淘汰缓存。memcache本身是为缓存而设计的服务器，因此没有过多考虑数据永久性的问题。

memcache,redis内部存储数据原理

https://blog.csdn.net/session_time/article/details/52618215

redis与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。


（23） 项目中哪里用到了数据库，怎么用的



# c++后台开发面试常见知识点总结（五）场景设计
搜索引擎的实现，会用到哪些重要的数据结构 
设计实现一个HTTP代理服务器 / web服务器 / FTP服务器/
设计实现cache缓存web服务器的网页访问记录
把一个文件快速下发到100w个服务器
将微信用户分为两组，组内的微信用户互相不为好友；用并查集
朋友之间的点对点关系用图维护，怎么判断两人是否是朋友；求朋友圈的个数
XX市有多少钢琴调音师傅？（费米问题）
范围1到1000的数，原本有1000个，互不重复，现多出来1个重复的数，怎么找到它
1-100顺序排列，丢失了一个怎么找到（二分法）
先手必胜策略问题
摆象棋的先手必胜策略
一个矩阵，从左上角到右下角，上下左右走，到达右下角的最短路径，
四辆小车，每辆车加满油可以走1公里，车子之间可以互相加油…
秒杀系统的架构设计
两个50亿url文件，找到相同url，内存4g
判断一个图是否连通？（开始说DFS，面试官说不满意，后来说并查集）
洗牌发牌算法
给你1MB的内存，你们怎么设计， 才能使其利用率最高，产生的碎片最少
BitMap局限与解决
memcache,redis
判断一个QQ号是否存在于40亿个QQ号中，4GB的空间，O(1)的时间
老鼠试毒药问题；
蚂蚁爬杆；
从50亿的整数集合里找出中位数
高德地图是怎么知道高速路哪里堵车了
微信的朋友圈数据在后台应该怎么存放
如果采用LRU的方法，QQ用户的数据在后台存放管理
给定两个线段的端点坐标，如何判断它们是否相交。（用向量叉乘）
王者荣耀是基于TCP还是UDP，为什么？
一个5L的桶子和6L的桶子，打出3L水
要是设计一个高并发服务器，可以从哪些角度去优化
要完成一个微博评论的部分，在用户进入新闻时优先看到自己好友对此新闻的评论，
一亿QQ用户，每个用户都有500好友，每个人都可能玩很多腾讯出的游戏，如何存储能使获取一个人的好友玩的游戏列表。
1000w（L）个整数排序，范围0到100w(S)，8g内存，计数排序
给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的
设计一个类似搜索扣扣好友列表，例如输入a显示前缀为a的所有好友
十亿个ip地址排序.
用数据结构模拟浏览器前进后退的操作
64匹马、8赛道，至少多少轮比赛找出速度最快的4匹马？
如何把访问次数过多的IP拉入黑名单
百度搜索的智能提示怎么实现，输入两个字，出来一些热搜
一亿个数字，找出最大的前 20 个
把上亿个字符串进行排序
1G内存，4G url，求重复的url ；或者是对url去重
 

摆象棋的先手必胜策略
微信的附近的人这个功能，如果让你实现，你准备怎么做，
如何设计一个好的字符串hash函数
 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

搜索引擎的实现，会用到哪些重要的数据结构   

https://www.cnblogs.com/Leo_wl/p/5470570.html

搜索引擎的索引其实就是实现单词-文档矩阵的具体数据结构。单词-文档矩阵从纵向看，可以得知每列代表某文档包含了哪些单词；从横向看，每行代表了哪些文档包含了某个单词。倒排索引是单词到文档映射关系的最佳实现方式。

单词词典：文档集合中出现过的所有单词构成的字符串集合，单词词典内每条索引项记载单词本身的一些信息(唯一单词ID等)及指向倒排列表的指针。单词词典用来维护文档集合中出现过的所有单词的相关信息，同时用来记载某个单词对应的倒排列表在倒排文件中的位置信息。在查询时到单词词典里查询，就能获得相应的倒排列表，并以此作为后序排序的基础。常用数据结构：哈希加链表和树形词典结构。

哈希加链表词典结构的主体是哈希表，每个哈希表项保存一个指针，指针指向冲突链表，相同哈希值的单词形成链表结构。构建过程：对文档进行分词；对于做好的分词，利用哈希函数获取哈希值；根据哈希值对应的哈希表项找到对应的冲突链表；如果冲突链表已经存在该单词不处理否则加入冲突连表。

树形词典结构：使用B树或者B+树的结构。与哈希表不同的是，需要字典项能按照大小排序，即 使用数字或字符序。树形结构中，使用层级查找，中间节点保存一定顺序范围的词典项，最底层的叶子节点存储单词的地址信息。

倒排列表：倒排列表用来记录哪些文档包含了某个单词。倒排列表由倒排索引项组成，每个倒排索引项由文档ID，单词在文档中出现次数TD，单词在文档中哪些位置出现过等信息。包含某单词的一系列倒排索引项形成了某个单词对应的倒排列表。

建立索引：可以使用两遍遍历文档的方法在内存里完成索引的创建。要求内存要足够大。第一遍遍历收集一些全局的统计信息。包括文档集合包含的文档个数N，文档集合内所包含的不同单词个数M，每个单词在多少个文档中出现过的信息DF。
将所有单词对应的DF值全部相加，就可以知道建立最终索引所需的内存大小是多少。获取信息后，根据统计信息分配内存等资源，同事建立好单词相对应倒排列表在内存中的位置信息。第二遍遍历逐个单词建立倒排列表信息。获得包含某个单词的每个文档的文档ID，以及这个单词在文档中的出现次数TF，然后不断填充第一遍扫描时所分配的内存。当第二遍扫描结束的时候，分配的内存正好被填充满，每个单词用指针所指向的内存区域“片段”，其起始位置和终止位置之间的数据就是这个单词对应的倒排列表。

 

设计实现一个HTTP代理服务器

基本原理：代理服务器作为真实服务器的一个代理端，客户端的请求信息不是直接发送到其真实请求的服务器而是发送到代理服务器，此时代理服务器是作为一个服务器，之后代理服务器通过解析客户端的请求信息，再向真实服务器发送请求报文，获得请求的信息，此时代理服务器是作为一个客户端。 

使用代理服务器的好处是：1. 在请求客户端和真实服务器之间添加了一层，这样就可控的对于请求的响应报文做一些限制或者是改变，例如网站过滤、钓鱼网站等，使得响应到客户端的信息是代理服务器处理过的；2、还有就是请求报文先发送到代理服务器，这样代理服务器可以设立缓存，通过对请求报文解析后代理服务器可以通过查找本地缓存，如果有缓存好的，并且通过向服务器发送是否更新的信息后得到没有修改后就可以直接从代理服务器将响应报文返回给客户端，这样减少了服务端的负载，减少了流量。

https://blog.csdn.net/rocketeerLi/article/details/83717613

 

实现一个web服务器

以FTP服务器为例
首先创建一个服务器socket，然后bind地址，listen监听，然后把socket加入多路转接监听链表。当有连接到达的时候，我们对socket调用accept，返回一个已连接套接字描述符，然后根据用户传输过来的文件名去查找文件，读取文件内容并回送给用户。

accept之后创建一个线程，如果使用线程池的话就从池中取一个空闲线程，然后把已连接文件描述符传给这个线程，然后让线程去处理这个用户请求，一个线程处理一个用户请求。

 

设计一个cache缓存web服务器的网页访问记录，该如何实现这个数据结构？

用队列，根据last visited排序，先进先出；队列每一个元素包含键值两部分，值就是访问的记录。再用一个hash表保存键值，这个值呢是指向队列元素的指针。

 

把一个文件快速下发到100w个服务器（不会）
（面试官之后说你可以想想迅雷是怎么做到下载速度那么快的）

树状： 1. 每个服务器既具有文件存储能力也应具有文件分发能力。

       2. 每个服务器接收到文件之后向较近的服务器分发，具体类似多叉树，应该挺快的。

索引状：1. 设置1000个缓存服务器，文件先下发到这些缓存上。（具体多少缓存、分几层缓存和具体业务有关。） 2. 每个缓存服务器接收1000个服务器取文件。

 

将微信用户分为两组，组内的微信用户互相不为好友；用并查集

我当即说出来逐次探测，又被逼问时间复杂度，O（n2）

dfs：微信用户之间的关系图包含很多连通分量的无向图，保存原始关系图G0(邻接矩阵)。拷贝一份可以修改的关系图G1,遍历图G1中每个节点并标记，若节点没有边，则不处理；若节点只有一条边，则将该节点的唯一邻接节点在G0中查找它的所有邻接节点，若hashmap中已有该节点或者有该节点的邻接节点，返回false;否则在图中将该节点的所有边断开，将该节点加入hashmap中；若节点只有多条边，则对该节点自身做上述处理；程序到最后则返回true;还可以用并查集

 并查集：

Pre[100],initial（int n），find(int x),unite(int x,int y)

https://blog.csdn.net/hlk09/article/details/81462771

 

朋友之间的点对点关系用图维护，怎么判断两人是否是朋友；求朋友圈的个数

Dfs 并查集，

http://www.cnblogs.com/grandyang/p/6686983.html

 

XX市有多少钢琴调音师傅？（费米问题）

首先从XX市有多少台钢琴开始，其次弄清楚需要多少调音师才能让这些钢琴保持音准。先列出一些知道的数据，然后是一些假设：

一、钢琴需要多久进行一次调音

二、为一台钢琴进行调音需要多长时间

三、一位钢琴调音师一年平均工作多少小时

四、纽约有多少架钢琴

 

范围1到1000的数，原本有1000个，互不重复，现多出来1个重复的数，怎么找到它

解答：求和相减，把给定的 1001个数相加的和减去（1+2+…+1000）即可得到答案。

 

1-100顺序排列，丢失了一个怎么找到（二分法）

二分法，比如第一次的话，你取arr[50]，看看是不是50,如果是，说明缺失的数在后面，如果是49，则缺失的数在[0-49]位置，包括49，依次类推即可

 

先手必胜策略问题：n本书，每次能够拿X-X本，怎么拿必胜，拿到最后剩下的算胜利。

N个糖果，每次只能取1个到6个，不能不取，你先取，请问是否有必胜策略，怎么取。

每次取到只剩7的倍数个糖果即可。因为剩下的为7的倍数时可以保证对方不能一次性取完。当取到最后剩下7个时，对方不能取完，然后自己可以取完。

 

摆象棋的先手必胜策略，每个人每轮摆一个，直到某一个人不能在空白的地方继续放下，就算输，那么你有必胜的方法吗,
第一个人摆在正中心(同心圆)，然后不管第二个人怎么摆，第一个人都和他玩中心对称。

 

一个矩阵，从左上角到右下角，每个位置有一个权值。可以上下左右走，到达右下角的最短路径怎么走。

如果只可以向右和向下走可以考虑dp

本题中，可以dfs递归实现。面试官说要优化。说了一下用迪杰斯特拉的思路，说可以。

迪杰斯特拉：https://blog.csdn.net/chen134225/article/details/79886928

 

 四辆小车，每辆车加满油可以走1公里，车子之间可以互相加油，问怎么能让一辆小车走最远。说了好几种方案，面试官引导我优化了一下，但是还是不满意，最后他说跳过。

答：四辆车跑1/4*1公里的时候，把其中一辆车的油分给其他三辆车，此时其他三辆车都满油，抛弃分油车；三辆车继续跑1/3*1公里的时候，把其中一辆车的油分给其他两辆车，此时其他两辆车都满油，抛弃分油车；两辆车继续跑1/2*1公里的时候，把其中一辆车的油分给另一辆车，此时最后1车满油，抛弃分油车，最后一辆车继续跑1公里；

最远跑（1/4+1/3+1/2+1）*公里。

 

秒杀系统的架构设计

https://blog.51cto.com/13527416/2085258?cid=700792

 

两个大文件存url，找相同url ，两个50亿url文件，找到相同url，内存4g

分别扫描A，B两个文件，根据hash(url)%k(k为正整数，比如k = 1000，k的取值保证内存可以放得下即可)将url划分到不同的k个文件中，比如a0，a1,....a999;b0，b1，...b999；这样处理后相同的url肯定在对应的小文件中（a0 vs b0,a1 vs b1,...a999 vs b999）因为相同的url%1000的值肯定相同，不对应的小文件不可能有相同的url；然后我们只要求出1000对小文件中相同的url即可。比如对于a0 vs b0，我们可以遍历a0，将其中的url存放到hash_map中，然后遍历b0，如果b0中的某个url在hash_map中，则说明此url在a和b中同时存在，保存下来即可。
布隆过滤器
 

如何判断一个图是否连通？（开始说DFS，面试官说不满意，后来说并查集）

图的遍历方法有dfs，bfs先遍历一遍图，判断是否所有的节点都遍历到

并查集的方法合并节点，最后数一共有多少集合，如果集合是1，证明连通。

 

 

洗牌发牌算法。 说了两种办法

答：1. 每次从未处理的数据中随机取出一个数字，然后把该数字放在数组的尾部，即数组尾部存放的是已经处理过的数字。这是一个原地打乱顺序的算法，算法时间复杂度O(n)。python的shuffle实现方式。

给你1MB的内存，你们怎么设计， 才能使其利用率最高，产生的碎片最少
采用分页法，1MB的内存，每4KB为单位进行，设置一个映射表，非连续性分配。
最坏的情况，只有一个4KB产生碎片。

 

BitMap局限与解决
数据碰撞。比如将字符串映射到 BitMap 的时候会有碰撞的问题，那就可以考虑用 Bloom Filter 来解决，Bloom Filter 使用多个 Hash 函数来减少冲突的概率。
数据稀疏。又比如要存入(10,8887983,93452134)这三个数据，我们需要建立一个 99999999 长度的 BitMap ，但是实际上只存了3个数据，这时候就有很大的空间浪费，碰到这种问题的话，可以通过引入 Roaring BitMap 来解决。
 

memcache中的数据结构是如何实现的
memcache是分布式缓存服务器，通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高动态、数据库驱动网站的速度。memcache中保存的数据都存储在memcache内置的内存存储空间中。重启memcache、操作系统都会导致全部数据消失。当memcache内容容量达到指定值之后，memcache就基于LRU算法淘汰缓存。memcache本身是为缓存而设计的服务器，因此没有过多考虑数据永久性的问题。
memcache,redis内部存储数据原理
https://blog.csdn.net/session_time/article/details/52618215
redis与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。
 

判断一个QQ号是否存在于40亿个QQ号中，4GB的空间，O(1)的时间
用bitmap（位图）;

根据待排序集合（QQ号）中最大的数，开辟一个位数组，用来表示待排序集合中的整数；待排序集合中的所有数字在位数组中的对应位置置1，其他的置0；

排序过程：将所有的位都置为0；通过读入文件中的每个QQ号检验每一位，如果该位为1，输出对应的整数。，将每个对应的位都置为1；

位图排序时，我们需要考虑：给出一个数，如何找到其对应位图的位置，方法就是首先找到该数对应的字节，然后在找到该数对应的位。例如一个QQ号是：983262245，则将bit的98326625位进行标记。bitset是C++提供的一种位集合的数据结构，它让我们可以像使用数组一样使用位，可以访问指定下标的bit位。因此将通过bitset容器进行存储42亿个qq号码。由于一个字节可以存放8个QQ号码，则4000000000/8/1014/1024 = 500.679Mb，内存合适，通过bit位下表来判断QQ号码是否存在。

bitset<40亿> bit;// 40亿的位图  bit.set(63834199);//将QQ号放入位图对应的位置中 bit.test(qq) 测试qq号是否存在。

https://blog.csdn.net/hpugym/article/details/80008946

 

老鼠试毒药问题：1000 个瓶子中有一瓶毒药，一只老鼠吃到毒药一周之内会死，如果要在一周之内检测出有毒药的一瓶，问至少需要几只老鼠？
1000个瓶子编号1-1000， 每个编号会有一个10位的二进制数字。 10只老鼠，依次喝掉所有二进制第一位是1的瓶子，第二位是1的瓶子。。。第十位是1的瓶子。 一周之后，死掉的老鼠说明毒药瓶子编号在对应二进制位置是1，否则是0。可以组合出毒药的编号。
 

蚂蚁爬杆：n只蚂蚁以每秒1cm的速度在长为Lcm的竿子上爬行。当蚂蚁爬到竿子的端点时就会掉落。由于竿子太细，两只蚂蚁相遇时，他们不能交错通过，只能各自反向爬回去。对于每只蚂蚁，我们知道它距离竿子左端的距离为Xi，但不知道它当前的朝向，请计算所有蚂蚁落下竿子所需的最短时间和最长时间。

最短时间：如果每只蚂蚁一开始就向着距离自己最近的竿子那一端爬，具体来说，在坐标0~L/2之间的蚂蚁朝着左端爬，L/2~L之间的蚂蚁朝着右端爬，那么蚂蚁之间就不会相遇(因为蚂蚁的速度是一样的)。所以在所有蚂蚁都处于自己最短的时间中只需要取出用时最长的那一个时间作为最终整体的最短用时即可。

最长时间：对于最长时间，得考虑相遇，因为只有不断相遇，不断折返，才能增加蚂蚁的爬行时间；但是如果我们可以不考虑蚂蚁的身份，将所有蚂蚁都视作相同无差别的，相当于每只蚂蚁是独立运动的，每次遇到别的蚂蚁后，就是变身一次而已，并不会影响其运动方向与轨迹。这样的话，求整体最长时间，就只需要求每只蚂蚁最长使用的情况下的最大值即可。

 

从50亿的整数集合里找出中位数. 

这里我说出来了两种方法.  分治法 和 位图法

 

高德地图是怎么知道高速路哪里堵车了，并且还能标记出来准确的路段？ 提出你的设想.

通过用户终端反馈的数据进行分析的。汽车的导航、手机用的导航等等，都会定时往服务器上传数据，后台通过你通过该段距离所用的时间，来进行判断是否拥堵。

 

问微信的朋友圈数据在后台应该怎么存放，主要要考虑的存放和读取（你朋友读取），不是系统设计，主要问你用的存储结构就行。

朋友圈用hash表和stack保存，每次更新后你朋友的数据那里会有一个queue去保存你这个新的朋友圈的信息。


如果采用LRU的方法，QQ用户的数据在后台存放管理？

我的理解就是理解成怎么实现对内存里的进行LRU。刚开始的想法有些漏洞，后来自己改进加面试官稍微提醒了一下最后结果感觉他还是比较满意的。

用hash表和链表结合，hash的key用时间结点，这样就能保证查询和插入删除操作都不会特别耗时。再次重申不一定是正确答案，你可以找其他大佬商量探讨

 

给定两个线段的端点坐标，如何判断它们是否相交。（用向量叉乘）

http://acm.hdu.edu.cn/discuss/problem/post/reply.php?postid=32179&messageid=1&deep=0

 

你觉得王者荣耀是基于TCP还是UDP，为什么？（其实答案是有安全保障的UDP，楼主答上了是这个）然后问道具体怎么设计的。（答得不太好）。

TCP使用场景：当对网络通信质量有要求时，比如：整个数据要准确无误的传递给对方，这往往对于一些要求可靠的应用，比如HTTP，浏览器，QQ文件传输；

UDP使用场景：对当前网络通讯质量要求不高的时候，要求网络通讯速度尽量的快，实时，这时就使用UDP ，如QQ语音，QQ视频，王者荣耀。

 

一个5L的桶子和6L的桶子，打出3L水

用装满水的5L倒进6L里,此时6L里还能装1L水,将5L再装满,倒进6L里,5L只能倒进1L,所以还剩下4L,同理,倒空6L,将剩余的4L倒入,再将5L装满,倒入6L里,由于6L只能再装入2L的水,所以,此时5L剩余部分为3L

 

要是设计一个高并发服务器，可以从哪些角度去优化。

https://blog.csdn.net/belalds/article/details/81106866

 

场景题：现在要完成一个微博评论的部分，想在用户进入新闻时优先看到自己好友对此新闻的评论，好友可能有多条评论，怎么设计结构。微博新闻评论设计

每一条新闻对应一个map<int,vector<int>>，key是用户id，value中包括了这个用户所有评论在新闻中的位置。每一条新闻对应一个hashmap存放新闻中的评论位置和评论内容，当前用户访问时，对他的每一个好友id在map里面查找，并对应显示。感觉面试官还比较满意，不过忘记说应该有评论和评论id的对应了，可能关系不大。

 

假如有一亿QQ用户，每个用户都有500好友，每个人都可能玩很多腾讯出的游戏，问如何存储能使获取一个人的好友玩的游戏列表。

用key-value存储，bitmap。使用memcached或redis, redis与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是Redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。

 

1000w（L）个整数排序，范围0到100w(S)，8g内存

计数排序  时间：O(1000W+100W)  空间：O（100w）

首先需要两个辅助数组，第一个数组A要记录最终排好序的输出数列(输出数组)，大小为n；第二个数组B要记录比某个数小的其他数字的个数，大小应当为K；

1、扫描整个集合S，对每一个Si∈S，找到在线性表L中小于等于Si的元素的个数T(Si)；

2、扫描整个线性表L，对L中的每一个元素Li，将Li放在输出数组的第T(Li)个位置上，并将T(Li)减1。

 

设计题，给每个组分配不同的IP段，怎么设计一种结构使的快速得知IP是哪个组的（想用Trie树，面试官让我再优化一下。使用hash,取得ip地址的网络号，使得同一组的ip地址hash值相同。


设计一个类似搜索扣扣好友列表，例如输入a显示前缀为a的所有好友，我说对好友列表用字典树Trie树排序，然后面试官说如果给搜索字段很长的话性能不好，然后我说了用文件索引，然后查找索引。

Trie，又称前缀树或字典树，用于判断字符串是否存在或者是否具有某种前缀的字符串。

 

十亿个ip地址排序.

之前在网上查了腾讯很喜欢问这种题目,主要是map reduce和bitmap两种思路去答就可以了.（bitset）

 

用数据结构模拟浏览器前进后退的操作
问题：依次访问完一串页面 a-b-c 之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面 b 和 a。当你后退到页面 a，点击前进按钮，就可以重新查看页面 b 和 c。但是，如果你后退到页面 b 后，点击了新的页面 d，那就无法再通过前进、后退功能查看页面 c 了。

解答思路：1. 使用两个栈，X 和 Y，把首次浏览的页面依次压入栈 X，当点击后退按钮时，再依次从栈X中出栈，并将出栈的数据依次放入栈 Y。点击前进按钮时，依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了。

2. 通过页面 b 又跳转到新的页面 d 了，页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y。

 

64匹马、8赛道，至少多少轮比赛找出速度最快的4匹马？（在提示下优化到12次，最优解为10或者11次）
https://www.cnblogs.com/wuyepeng/p/9740963.html

 

如果把访问次数过多的IP拉入黑名单，怎么实现，用什么数据结构，写个伪码
创建两个Map，一个（ipMap）用来存放用户Ip和访问次数，访问时间等主要信息，另一个（limitedIpMap）用来存放被限制的用户IP。Map的key为用户的IP，value为具体内容。当用户访问系统时，通过IPFilter检查limitedIpMap中是否存在当前IP，如果存在说明该IP之前存在过恶意刷新访问，已经被限制，跳转到异常提示页面；如果limitedIpMap

中不存在则检查ipMap中是否存在当前IP，如果ipMap中不存在则说明用户初次访问，用户访问次数+1，初始访问时间为当前时间；如果存在则检查用户访问次数是否在规定的短时间内进行了大量的访问操作；如果是，则将当前IP添加到limitedIpMap中，并跳转到异常提示页面，否则不进行操作，直接放行本次请求。

来一条设计题。百度搜索的智能提示怎么实现，输入两个字，出来一些热搜
Trie字典树+堆（Top K）吧，然后balabala（第三次。。。感觉面试官不是很满意我的答案)

https://www.cnblogs.com/chenyang920/p/5940190.html

用trie字典树存储大量字符串，以用户输入为前缀，前缀固定时，存储相对来说比较热的后缀。那又如何统计热词呢？ TOP K算法统计热词。

 

如果给你 一亿个数字，找出最大的前 20 个。（TOP K 问题），如果我只要第二十个怎么优化。（利用建堆  快速排序）
最大的前 20 个：建立小顶堆，先拿20个数建堆，然后依次添加剩余元素，如果大于堆顶的数（20最小的），用这个数替换堆顶，并调整结构使之仍然是一个最小堆，这样，遍历完后，堆中的20个数就是所需的最大的20个。建堆时间复杂度是O（logK），算法的时间复杂度为O（nlogK）（n为1亿，m为20）。

注：如果数据量大的时候，可以先将数据根据哈希算法打散到各个小文件。每个小文件里，进行同样的操作。接着再把所有小文件的前20个取出。效果应该同理吧。

只要第二十个：利用快速排序；

 

如果给你一个文件，文件里有上亿个无序字符串，设计一个算法把上亿个字符串进行排序。接着把这个有序的字符串输入到一个新的文件当中。（内存有限制）
字符串排序，我采用的是哈希切分，打散至小文件。接着多路归并。

（将大文件切割成小文件，每个小文件内归并排序；对所有的小文件进行归并排序——多重归并排序）

Bitmap、Bloom过滤器

 

1G内存，4G url，求重复的url ；或者是对url去重
将文件通过哈希函数散列成多个小的文件，由于哈希函数所有重复的URL只可能在同一个文件中，在每个小文件中利用一个哈希表做次数统计。就能找到重复的URL。这时候要注意的就是给了多少内存，我们要根据文件大小结合内存大小决定要分割多少文件；本题中分割成4个文件

 

50个红球50个蓝球，放到2个袋子里，从两个袋子各取1个球，让2个都是红球的概率最大，怎么放
把一个红球单独放到一个盒子，另外49个红球和50个篮球放在一个盒子，0.75

 

一个函数返回值为 bool 类型。但是返回 true 与 false 的概率不是百分之五十对百分之五十。要求利用这个函数设计一个新函数，使得新函数的返回值的概率为 50%。
函数返回true与false概率不同，但是函数两次返回为tf与ft的概率是一样的。如果返回结果是tt或ff那么继续调用两次。直至出现tf或ft

 

微信的附近的人这个功能，如果让你实现，你准备怎么做，

地理位置网格分块，存块ID，然后四叉搜索。你的经纬度换算成网格ID，同网格的人撸出来，临近网格的人撸出来，搞定。把地理位置分块，怎么把经纬度转化成网格 ID 呢。本质上就是hash

客户端固定时间发送经纬度（x,y）到服务器s，服务器存储每个登陆的用户的经纬度到表t中，表t按照经纬度分表，将地图分成一个个的小格子。当用户点击“附近的人”时，对用户（x,y）进行计算，最多一次查询其中的4个格子（子表），计算两点间距离获取结果（有点像桶排序）。性能上可以将表t替换为内存结构，容灾即可。
从实际的微信提供的功能来看，附近的人并不太多，估计是其对地图划分的格子很小。

MongoDB的LBS功能实现附近的人

 

https://www.nowcoder.com/discuss/165952?type=0&order=0&pos=414&page=1

 

如何设计一个好的字符串hash函数

对于一个Hash函数，评价其优劣的标准应为随机性或离散性，即对任意一组标本，进入Hash表每一个单元（cell）之概率的平均程度，因为这个概率越平均，两个字符串计算出的Hash值相等hash collision的可能越小，数据在表中的分布就越平均，表的空间利用率就越高。

C++ 11 定义了一个新增的哈希结构模板定义于头文件 <functional>：std::hash<T>，模板类，（重载了operator()），实现了散列函数: unordered_map和unordered_multimap 默认使用std::hash; std::hash;实现太简单

同时，C++ STL 里面实现了一个万用的hash function 针对任何类型的

 

 

boost::hash 的实现也是简单取值。

DJBHash是一种非常流行的算法，俗称"Times33"算法。Times33的算法很简单，就是不断的乘33，原型如下：

hash(i) = hash(i-1) * 33 + str[i]，Time33在效率和随机性两方面上俱佳

https://blog.csdn.net/g1036583997/article/details/51910598




# c++后台开发面试常见知识点总结（六）算法手写
链表倒转  leetcode-206
连续子数组最大和问题(和最大的连续子序列的和)   leetcode-53
输出字符串中最长的回文子串长度？  leetcode-5
一个字符串,求最长无重复子串的长度？  leetcode-3
最长递增子序列  leetcode-300
反转一个字符串。。。。。。（手写代码） leetcode-344
数组中存在一个大于n/2次的数，如何以最优方法查找它？LeetCode 169 \ 229
一个字符串中{}  [ ]  ()匹配问题     LeetCode  20
一个数组，只有一个数字出现奇数次，其余数字出现偶数次 LeetCode  136
给定一个ip地址，编码使得ip和32位整数呈双射关系   LeetCode  93
求一个数组逆序对的个数  LeetCode  629
1个32位整数，计算二进制格式下有多少个1  LeetCode  191
最小生成树与并查集  leetcode684，685， 721
 

比较两二叉树是否相同（手写代码）LeetCode  100
手写判断大小端的代码
单链表找倒数第n个节点   LeetCode  19
把一颗二叉树原地变成一个双向链表？  114
判断一个无符号的整数是不是2的n次方？ 231
int atoi(char *str)？ 8
栈的getmin()操作 O（1） 155
用栈实现队列，用队列实现栈？232  225
实现strstr函数  28
整数a和b，求a的b次方的最后三位数
算法题：将字符串转换成人民币大写（半小时后发邮箱）
如何删除map中的奇数节点
恢复翻转数组
二分法
排序
手写String
memcpy函数的实现
strcpy函数的实现
BST的第K小的节点  230
判断链表是否有环，如果有，返回环的入口节点；求环的长度   141
求一个数组逆序对的个数    629
翻转数组和恢复翻转数组   
删除单链表中间节点
判断两个单链表是否相交
r行c列的0,1数组，找到最大的全为1的正方形？
连续子数组最大和问题(和最大的连续子序列的和)
excel中，标志列的如AA,AZZ ,BS，求这些列到底是第几列
二叉树两个节点的最近公共祖先
去掉字符串中的空格字符
删除字符串开始和结尾处的空格，并将中间的多个连续的空格合并成一个
char *s1, const char *s2，删除s1中s2出现过的字符
单链表判环
判断一个数是不是回文数
求一个集合的所有子集，递归实现，非递归实现
旋转有序数组的二分查找
删除数组中的重复元素  
实现一个计算器计算简单的表达式字符串
memcopy和memove
 

微信小程序团队一共有 n 名成员，决定出去秋游，在海边遇到出租摩托艇的杰克马
给定一个二叉树，节点值为0-9， LeetCode 129
写一个二叉树翻转，然后写个测试
trcpy安全性，如何实现安全，strnpy,写一下并测试，
写sql语句(A表存储有每个电话号码当月通话记录，表B是电话号码集合，求表B每个号码通话次数)
如何设计一个好的字符串hash函数
两字符串最长公共子串， 最长公共子序列
打印二叉树每层最右边的节点 层序遍历 LeetCode 199
顺时针回形打印矩阵的元素 LeetCode 54
判断在一个矩阵中是否存在一条包含某字符串所有字符的路径 LeetCode 79
3sum 数组中三数之和为0的所有三元组 leetcode 15
判断一个字符串是不是两个有序的字符串交错组成的。 Leetcode 97
编程题：递增数组中找两个数和为某个固定值。设计测试用例 Leetcode 1
给你一个数组和数组元素的个数，求平均值。
两个非常大的数相加 Leetcode 415
手写下单例模式？
 

 

 

 

 

链表倒转
从尾到头打印链表（使用栈或者使用递归）

链表倒转

typedef struct ListNode
{
int data;
ListNode *next;
};

 

ListNode* reverseList1(ListNode *head)

{

if (head == NULL)

return head;

ListNode* dummy = new ListNode;

dummy->data = -1;

dummy->next = head;

ListNode *Cur = dummy->next;

ListNode *tmp = Cur->next;

while (tmp != NULL) {

Cur->next = tmp->next;

tmp->next = dummy->next;

dummy->next = tmp;

tmp = Cur->next;

}

Cur->next = NULL;

return dummy->next;

}

 

 

 

 

 

 

 

 

 

 

 

连续子数组最大和问题(和最大的连续子序列的和)
 

输出字符串中最长的回文子串长度？
https://blog.csdn.net/h_xy_zwb/article/details/64124271

DP:O(n^2)

string longestPalindrome(string s) {

        int len=s.size();

        vector<vector<int>> flag(len,vector<int>(len,0));

        int maxres=0,idx=0;

        for(int i=0;i<len;i++){

            for(int j=0,k=i;j<len&&k<len;j++,k++){

                if(k==j) flag[j][k]=1;

                else if(s[k]==s[j]&&j+1==k) flag[j][k]=2;

                else if(s[k]==s[j]&&flag[j+1][k-1]>0) flag[j][k]=flag[j+1][k-1]+2;

                else flag[j][k]=0;

                if(flag[j][k]>maxres){

                    maxres=flag[j][k];

                    idx=j;

                }

            }

        }

        return s.substr(idx,maxres);

}

一个字符串,求最长无重复子串的长度？

 

最长递增子序列：

思想：在求以ai为末元素的最长递增子序列时，找到所有序号在L前面且小于ai的元素aj，即j<i且aj<ai。如果这样的元素存在，那么对所有aj,都有一个以aj为末元素的最长递增子序列的长度f(j)，把其中最大的f(j)选出来，那么f(i)就等于最大的f(j)加上1，即以ai为末元素的最长递增子序列，等于以使f(j)最大的那个aj为末元素的递增子序列最末再加上ai；如果这样的元素不存在，那么ai自身构成一个长度为1的以ai为末元素的递增子序列。

 

手写下单例模式？
 

class singleton{
protected:
  singleton(){}
private:
  static singleton* p;
public:
  static singleton* getInstance();
}
singleton* singleton::p = new singleton();
singleton* singleton::getInstance(){
  return p;
}
 
 

写个string类
反转一个字符串。。。。。。（手写代码）
剑指58

.对于string类型的：使用algorithm中的reverse函数，reverse(s.begin(),s.end());
对于用char定义的字符串：使用string.h中的strrev函数，char s[]="123456";//不能是string类型；strrev(s);
实现：设置两个指针，一头一尾，往中间移动；

 

数组存中在一个大于n/2次的数，如何以最优方法查找它？
int MoreThanHalfNum(int *arr, int len)
 2 {
 3     int result = arr[0];
 4     int count = 1;
 5
 6     for(int i = 1; i < len; ++i)
 7     {
 8         if(arr[i] == result)
 9             count ++;
10         else if(count == 0)
11         {
12             result = arr[i];
13             count = 1;
14         }
15         else
16             count --;
17     }
18     return result;
19 }
 

一个字符串中{}  [ ]  ()匹配问题

bool isValid(string s) {

        std::stack<char> st;

        for(int i = 0; i < s.size(); ++i)

        {

            char ch = s.at(i);

            if(ch == '(' || ch == '[' || ch == '{')

                st.push(ch);

            else if(st.size() > 0 && ((ch == ')' && st.top() == '(') || (ch == ']' && st.top() == '[') || (ch == '}' && st.top() == '{')))

                st.pop();

            else

                return false;

        }

 

        return st.size() == 0;

}

 

一个数组，只有一个数字出现奇数次，其余数字出现偶数次，如何得到这个数字？如果出现奇数次的数字有2个呢？
可以用位运算实现，如果将所有所有数字相异或，则最后的结果肯定是那两个只出现一次的数字异或的结果，所以根据异或的结果1所在的最低位，把数字分成两半，每一半里都还有只出现一次的数据和成对出现的数据
这样继续对每一半相异或则可以分别求出两个只出现一次的数字

给定一个ip地址，编码使得ip和32位整数呈双射关系
int IpToInt(string s)

{   int ret=0;  int num=0;

       for(int i=0;i<s.size();i++)

       {

              if(s[i]!='.')  {num=num*10+(s[i]-'0');}

              else

              {

                     cout<<num<<endl;

                     ret=ret<<8;

                     ret+=num;

                     cout<<ret<<endl;

                     num=0;

              }

       }

       ret=ret<<8;

       ret+=num;

       return ret;    

}

求一个数组逆序对的个数
 

基于归并排序的思想统计逆序对：先把数组分割成子数组，再子数组合并的过程中统计逆序对的数目。统计逆序对时，先统计子数组内部的逆序对的数目，再统计相邻子数组的逆序对数目。

 

1个32位整数，计算二进制格式下有多少个1，不通过循环怎么做
 

通过n与n-1相& 清楚n最右边的1；

int BitCount(int n){

        int c=0;//计数器

        while(n){

          n&=(n-1);

++c;

}

        return c;

}

 

算法 最小生成树
Prim+ Kruskal算法

https://www.cnblogs.com/GHzz/p/9148279.html

比较两二叉树是否相同（手写代码）。现在我才明白，大概是在考我用递归怎么遍历树，我当时写的居然是以按层遍历的方式去遍历树，
递归

 

 

 

手写判断大小端的代码

https://blog.csdn.net/kit_9875507/article/details/44264663

大小端的本质就是不同的存储方式

大端模式：字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中。

小端模式：字数据的高字节存储在高地址中，而字数据的低字节则存放在低地址中。

根据这个特性，假设我们初始化了一个int变量i为0x12345678，其地址为0x100，根据定义在小端模式下
0x100一个字节内的值为0x78，类推0x101=>0x56，0x102=>0x34，0x103=0x12，根据这个编程如下

int checkSystem(void)
{
       int i = 0x12345678;
       char *c = &i;
       return ((c[0] == 0x78) && (c[1] == 0x56) && (c[2] == 0x34) && (c[3] == 0x12));
}

int main(void)

{

       if(checkSystem())

              printf("little endian\n");

       else

              printf("big endian\n");

    return 0;

}

 

单链表找倒数第n个节点，说所有你能想到的方法。

方法一：遍历链表，记录链表的长度total，再次遍历链表，第total - N - 1个节点就是查找结果，需要遍历两次链表

方法二：使用两个指针，通过移动指针，遍历一次链表，p指针首先移动n-1步，然后p和q同时移动，直到p.next == null，此时q所指向的节点就是所求


 

怎么把一颗二叉树原地变成一个双向链表？

 

转换成有序双向链表：https://www.cnblogs.com/wanglei5205/p/8780086.html

 

 

怎么判断一个无符号的整数是不是2的n次方？

思路：一个整数如果是2的整数次方，那么它的二进制表示中有且只有一位是1，而其他所有位都是0。把这个整数与这个整数减去1之后进行与运算，那么这个整数当中唯一的

1会变为0，这个整数也变为0；

 

 

int atoi(char *str)？
 

//atoi
enum ={Invalid = 0, Valid};
bool errno = Invalid;
int atoi(const char * str) 
{
    long long num = 0; //point1:可能溢出，所以用long long存
    errno = Invalid;//初始设输入为不合法输入
    if (str!=nullptr && *str != '\0') //point2：//考虑了空串和空指针
    {
        bool minus = false;
        if (*str == '+')
        {  
            ++str;
        }
        else if (*str == '-')
        {
            ++str;
            minus = true;
        }
        if (*str!='\0') //只有符号，Invalid 
            atoiCore(str, minus, num);
    }
    return (int)num; //已经检查过溢出，保证了num在int范围内   
}
 
void atoiCore(const char *str, bool minus, long long &num)
{
    while ('\0' != *str)
    {
        if (*str >= '0' && *str <= '9')
        {
            num = num*10 + (*str - '0');
            ++str;
            if ((!minus && num > 0x7FFFFFFF)||(minus && (-num) < (signed int)0x80000000))//输入溢出
            {
                errno = Invalid;
                num = 0;
                return;
            }
        }
        else   //输入非法字符
        {
                errno = Invalid;
                num = 0;
                return;
        }
    }
    if (minus)
        num = -num;
    errno = Valid;  //标志输入合法
}
 

栈的getmin()操作 O（1）
template <typename T> class NewStack

{

private :

    std::stack<T> stack_data;

    std::stack<T> stack_support;

public:

     NewStack();

    ~NewStack();

    void push( T value)

    {

        stack_data.push (value);

        if (stack_support.size()==0 || stack_support.top()>value)

            stack_support.push(value);

        else:

            stack_support.push (stack_support.top());

    }

   

    void pop()

    {    if (stack_data.size()>0 && stack_support.size()>0)

            {

            stack_data.pop;

            stack_support.pop;

            }

    }

    T min()

    {

        if (stack_data.size()>0 && stack_support.size()>0)

        {

            return stack_support.top();

        }

    }

用栈实现队列，用队列实现栈？
使用队列实现栈:

class MyStack {

public:

    MyStack() {

    }

    void push(int x) {

        queue<int> temp; //建立一个辅助队列

        while(q.empty() == false){ //将队列q中所有元素存入辅助队列中

            temp.push(q.front());

            q.pop();

        }

        q.push(x); //向队列中压入元素，放在队首

        while(temp.empty() == false){ //逐个将辅助队列中的元素送回队列q中

            q.push(temp.front());

            temp.pop();

        }

    }

   

    int pop() {

        int a = q.front(); //将队列首元素返回

        q.pop();  //删除队首

        return a;

    }

   

    int top() {

        return q.front();  //返回队首

    }

   

 

    bool empty() {

        return q.empty();

    }

private:

    queue<int> q;

};

用栈实现队列

class MyQueue {

public:

    MyQueue() {

    }

    void push(int x) { //将元素放到栈底

        stack<int> temp;

        while(s.empty() == false){

            temp.push(s.top());

            s.pop();

        }

        s.push(x);

        while(temp.empty() == false){

            s.push(temp.top());

            temp.pop();

        }

    }

    int pop() {

        int a = s.top();

        s.pop();

        return a;

    }

    int peek() {

        return s.top();       

    }

    bool empty() {

        return s.empty();

    }

private:

    stack<int> s, temp;

};

 

实现strstr函数

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

 

整数a和b，求a的b次方的最后三位数

 

.

算法题：将字符串转换成人民币大写（半小时后发邮箱）
https://blog.csdn.net/forlove_you/article/details/51248978

 

如何删除map中的奇数节点
遍历删除，考虑迭代器失效问题

for(ITER iter=mapTest.begin();iter!=mapTest.end();++iter)
{ if（iter指向的元素是奇数）

    mapTest.erase(iter);

} //错误，erase会让迭代器会失效！

 

for(ITER iter=mapTest.begin();iter!=mapTest.end();)
{ if（iter指向的元素是奇数）

mapTest.erase(iter++);//正确，iter值传递之后，再++；

}

for(ITER iter=mapTest.begin();iter!=mapTest.end();)
{ if（iter指向的元素是奇数）
iter=mapTest.erase(iter);// erase() 成员函数返回下一个元素的迭代器

}

 

翻转数组和恢复翻转数组

找分界点：找分界点可以用一个指针来，遍历找到第一个下降的点，如果没有找到，说明数组已经是排好的。

 

 

二分法：

普通

int binary_search(int*arr,int l,int h,int key){

         while (l <= h){

                 int m = l + (h - l) / 2;

                 if (arr[m] == key)

                          return m;

                 else if (arr[m] > key)

                          h = m - 1;

                 else l = m + 1;

         }

         return -1;

}

lower_bound

int binary_search(int*arr, int l, int h, int key){//找到第一个插入的位置

         while (l <h){

                 int m = l + (h - l) / 2;

                 if (arr[m] >= key)

                          return h=m;

                 else l = m + 1;

         }

}

 

排序

插入排序

void insert_sort(int* arr, int l, int h) {

         for (int i = l + 1; i <= h; ++i)

                 for (int j = i; j > 0; --j){

                          if (arr[j] < arr[j - 1]){

                                   iter_swap(&arr[j], &arr[j-1]);

                          }

                 }

         }

 

快速排序

int partition(int* arry, int l, int h){

         int pivot = arry[h];

         while (true){

                 while (arry[l] < pivot) ++l;

                 while (arry[h] > pivot) --h;

                 if (!(l < h)) return l;

                 iter_swap(&arry[l], &arry[h]);

                 ++l;

                 --h;

         }

}

void quick_sort(int* arr, int l, int h) {

         if (l >= h) return;

         int m = partition(arr, l, h);

         quick_sort(arr, l, m-1);

         quick_sort(arr, m , h);

}

堆排序

void percDown(int* arr, int l, int h, int k) {

         int child, tmp;

         for (tmp = arr[k]; (k - l) * 2 + l + 1 <= h; k = child) {

                 child = (k - l) * 2 + l + 1;

                 if (child + 1 <= h && arr[child] < arr[child + 1]) ++child;

                 if (arr[child] > tmp) arr[k] = arr[child];

                 else break;

         }

         arr[k] = tmp;

}

 

void heap_sort(int* arr, int l, int h) {

         for (int i = l + (h - l) / 2; i >= l; --i) {

                 percDown(arr, l, h, i);

         }

         for (int i = h; i >= l; --i) {

                 int tmp = arr[l];

                 arr[l] = arr[i];

                 arr[i] = tmp;

                 percDown(arr, l, i - 1, l);

         }

}

 

归并排序

void merge_sort(int* arr, int l, int h) {

         if (l == h) return;

         int m = l + (h - l) / 2;

         merge_sort(arr, l, m);

         merge_sort(arr, m + 1, h);

         int * tmp = new int[h - l + 1];

         int i = l, j = m + 1, k = 0;

         while (i <= m && j <= h) {

                  if (arr[i] <= arr[j]) tmp[k++] = arr[i++];

                 else tmp[k++] = arr[j++];

         }

         while (i <= m) tmp[k++] = arr[i++];

         while (j <= h) tmp[k++] = arr[j++];

         for (int i = l; i <= h; ++i) {

                 arr[i] = tmp[i - l];

         }

         delete []tmp;

}

冒泡排序

void bubble_sort(int* arr, int l, int h) {

         for (int i = l; i <= h; ++i) {

                 for (int j = l; j <= h - i + l - 1; ++j) {

                          if (arr[j] > arr[j + 1]) {

                                   int tmp = arr[j];

                                   arr[j] = arr[j + 1];

                                   arr[j + 1] = tmp;

                          }

                 }

         }

}

选择排序

void select_sort(int* arr, int l, int h) {

         for (int i = l; i <= h; ++i) {

                 int id = i;

                 for (int j = i + 1; j <= h; ++j) {

                          if (arr[j] < arr[id]) {

                                   id = j;

                          }

                 }

                 int tmp = arr[i];

                 arr[i] = arr[id];

                 arr[id] = tmp;

         }

}

 

手写String

class String{

public:  String(const char *str = NULL); //普通构造函数

String(const String &other);  //拷贝构造函数

String & operator=(String &other) ; //赋值函数

~String(void); //析构函数

private:  char* m_str;

};

//普通构造函数

String::String(const char* str){

    if(str==NULL) //如果str为NULL，存空字符串{

        m_str = new char[1]; //分配一个字节

        *m_str = ‘\0′; //赋一个’\0′

}else{

       str = new char[strlen(str) + 1];//分配空间容纳str内容

        strcpy(m_str, str); //复制str到私有成员m_str中

    }

}

//析构函数

String::~String(){

    if(m_str!=NULL) //如果m_str不为NULL，释放堆内存{

        delete [] m_str;

        m_str = NULL;

}

}

//拷贝构造函数

String::String(const String &other){

    m_str = new char[strlen(other.m_str)+1]; //分配空间容纳str内容

    strcpy(m_str, other.m_str); //复制other.m_str到私有成员m_str中 

}

//赋值运算符函数

String & String::operator=(String &other){

    if(this == &other) //若对象与other是同一个对象，直接返回本{

        return *this

}

    delete [] m_str; //否则，先释放当前对象堆内存

    m_str = new char[strlen(other.m_str)+1]; //分配空间容纳str内容

    strcpy(m_str, other.m_str); //复制other.m_str到私有成员m_str中

    return *this；

}

memcpy函数的实现

void *memcpy(void *dest, const void *src, size_t count) {

 char *tmp = dest;

 const char *s = src;

 

 while (count--)

  *tmp++ = *s++;

  return dest;

}

strcpy函数的实现

char *strcpy(char *dst,const char *src) { 

      assert(dst != NULL && src != NULL); 

      char *ret = dst; 

      while((* dst++ = * src++) != '\0') ; 

      return ret; 

 }

 

 

 

 

 

BST的第K小的节点

 

http://www.cnblogs.com/grandyang/p/4620012.html

 

判断链表是否有环，如果有，返回环的入口节点；求环的长度

思路：采用两个指针walker和runner，walker每次移动一步而runner每次移动两步。当walker和runner第一次相遇时，证明链表有环 ；然后采用两个指针，一个从表头出发，一个从相遇点出发，一次都只移动一步，当二者相等时便是环入口的位置；

ListNode *detectCycle(ListNode *head) {

        auto walker = head;

        auto runner = head;

        while(runner && runner->next)//设置快慢指针，并找到相遇点

        {

            walker = walker->next;

            runner = runner->next->next;

            if(walker == runner)

                break;

        }

        if(!runner || !runner->next) //单链表无环

            return nullptr;

        auto headWalker = head;//从头节点出发

        auto crossWalker = walker; //从相遇点出发

        while(headWalker != crossWalker)

        {

            headWalker = headWalker->next;

            crossWalker = crossWalker->next;

        }

        return headWalker; //环的入口点

    }

 

 

 

 

求一个数组逆序对的个数
基于归并排序的思想统计逆序对：先把数组分割成子数组，再子数组合并的过程中统计逆序对的数目。统计逆序对时，先统计子数组内部的逆序对的数目，再统计相邻子数组的逆序对数目。

 

翻转数组和恢复翻转数组

找分界点：找分界点可以用一个指针来，遍历找到第一个下降的点，如果没有找到，说明数组已经是排好的。

 

 

给定链表头指针，中间结点的指针，如何删除单链表中间节点

快慢指针找中间值，

https://blog.csdn.net/cherrybomb1111/article/details/79803972

 

判断两个单链表是否相交，相交则找出两个链表的第一个公共子节点

思路1：分别遍历两个链表，得到分别对应的长度。然后求长度的差值，把较长的那个链表向后移动这个差值的个数，然后一一比较即可。

思路2：让两个指针分别从两条链表的开头开始往后遍历，当其中一条遍历到末尾时，我们将其跳到另一个条链表的开头继续遍历，一直遍历到两个指针相等为止。相等只有两种情况，一种情况是在交点处相遇，另一种情况是在各自的末尾的空节点处相等。，

为什么一定会相等呢，因为两个指针走过的路程相同，是两个链表的长度之和，所以一定会相等。

    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {

        if (!headA || !headB) return NULL;

        ListNode *a = headA, *b = headB;

        while (a != b) {

            a = a ? a->next : headB;

            b = b ? b->next : headA;

        }

        return a;

    }

 

 

 

 

r行c列的0,1数组，找到最大的全为1的正方形？

https://blog.csdn.net/nk_test/article/details/48901853

 

 

连续子数组最大和问题(和最大的连续子序列的和)
excel中，标志列的如AA,AZZ ,BS，求这些列到底是第几列。26进制转换问题：
Int transfer(const string& s){
int res=0;
for(int i=0;i<s.length();i++){
   result=(result*26+(s[i]-'a'+1));
}
return res;
}
 

二叉树两个节点的最近公共祖先，没答出来

https://www.cnblogs.com/grandyang/p/4641968.html

 

 

去掉字符串中的空格字符

https://blog.csdn.net/qian2213762498/article/details/81705647

void trim(string &s)

  {

    int index = 0;

    if( !s.empty())

     {

         while( (index = s.find(' ',index)) != string::npos)

        {

            s.erase(index,1);

       }

     }

}

 

删除字符串开始和结尾处的空格，并将中间的多个连续的空格合并成一个。

void FormatString(char str[], int len)

{

  if(str == NULL || len <= 0)

  return;

  int i = 0, j = 0;

  while(str[i] == ' ')//开头的空格

    i++;

  while(str[i] != '\0')

  {

    if(str[i] == ' ' && (str[i+1] == ' ' || str[i+1] == '\0'))

    {

//中间或者结尾的空格

        i++;

        continue;

    }

    str[j++] = str[i++];

  }

  str[j] = '\0';

}

 

char *s1, const char *s2，删除s1中s2出现过的字符

思路：用一个256大小的数组，每个表示字符的状态，把s2读一遍，把每个字母对应的数字变为1表示存在，然后遍历s1，把状态为1的删掉

https://blog.csdn.net/m0_38099899/article/details/81231886

 

单链表判环

设两个指针，一个每次走一步的慢指针和一个每次走两步的快指针，如果链表里有环的话，两个指针最终肯定会相遇。

是不是：bool hasCycle(ListNode *head) {

        ListNode *slow = head, *fast = head;

        while (fast && fast->next) {

            slow = slow->next;

            fast = fast->next->next;

            if (slow == fast) return true;

        }

        return false;

    }

找环入口：ListNode *detectCycle(ListNode *head) {

        ListNode *slow = head, *fast = head;

        while (fast && fast->next) {

            slow = slow->next;

            fast = fast->next->next;

            if (slow == fast) break;

        }

        if (!fast || !fast->next) return NULL;

        slow = head;

        while (slow != fast) {

            slow = slow->next;

            fast = fast->next;

        }

        return fast;

    }

 

 

 

 

判断一个数是不是回文数

bool isPalindrome(int x) {

        if (x < 0 || (x % 10 == 0 && x != 0)) return false;

        int revertNum = 0;

        while (x > revertNum) {

            revertNum = revertNum * 10 + x % 10;

            x /= 10;

        }

        return x == revertNum || x == revertNum / 10;

    }

 

http://www.cnblogs.com/grandyang/p/4125510.html

 

求一个集合的所有子集，递归实现，非递归实现

http://www.cnblogs.com/grandyang/p/4309345.html

 

vector<vector<int> > subsets(vector<int> &S) {

        vector<vector<int> > res(1);

        sort(S.begin(), S.end());

        for (int i = 0; i < S.size(); ++i) {

            int size = res.size();

            for (int j = 0; j < size; ++j) {

                res.push_back(res[j]);

                res.back().push_back(S[i]);

            }

        }

        return res;

    }

 

旋转有序数组的二分查找  http://www.cnblogs.com/grandyang/p/4325648.html

无重复数字：int search(vector<int>& nums, int target) {

        int left = 0, right = nums.size() - 1;

        while (left <= right) {

            int mid = left + (right - left) / 2;

            if (nums[mid] == target) return mid;

            else if (nums[mid] < nums[right]) {

                if (nums[mid] < target && nums[right] >= target) left = mid + 1;

                else right = mid - 1;

            } else {

                if (nums[left] <= target && nums[mid] > target) right = mid - 1;

                else left = mid + 1;

            }

        }

        return -1;

}

有重复数字：http://www.cnblogs.com/grandyang/p/4325840.html

bool search(int A[], int n, int target) {

        if (n == 0) return false;

        int left = 0, right = n - 1;

        while (left <= right) {

            int mid = (left + right) / 2;

            if (A[mid] == target) return true;

            else if (A[mid] < A[right]) {

                if (A[mid] < target && A[right] >= target) left = mid + 1;

                else right = mid - 1;

            } else if (A[mid] > A[right]){

                if (A[left] <= target && A[mid] > target) right = mid - 1;

                else left = mid + 1;

            } else --right;

        }

        return false;

    }

 

删除数组中的重复元素  

 

有序数组中去除重复项  http://www.cnblogs.com/grandyang/p/4329128.html

int removeDuplicates(vector<int>& nums) {

        if (nums.empty()) return 0;

        int j = 0, n = nums.size();

        for (int i = 0; i < n; ++i) {

            if (nums[i] != nums[j]) nums[++j] = nums[i];

        }

        return j + 1;

    }

 

实现一个计算器计算简单的表达式字符串

+-： http://www.cnblogs.com/grandyang/p/4570699.html

+-*/:  http://www.cnblogs.com/grandyang/p/4601208.html

+-*/():  http://www.cnblogs.com/grandyang/p/8873471.html

 

 

 

 

memcopy和memove的区别？memcopy和memove的实现？

https://blog.csdn.net/li_ning_/article/details/51418400

都是拷贝一定长度的内存的内容，区别是当内存发生局部重叠的时候，memmove保证拷贝的结果是正确的，memcpy不保证拷贝的结果的正确。

 

 

 

memcpy函数的实现

void *memcpy(void *dest, const void *src, size_t count) {

 char *tmp = dest;

 const char *s = src;

 

 while (count--)

  *tmp++ = *s++;

  return dest;

}

 

 

给定一个二叉树，节点值为0-9，从根节点到叶子结点组成一个数，求二叉树所有组成的数的和

https://blog.csdn.net/i_am_bird/article/details/78173454

 

Rand()的范围是多少，要是生成大于范围的的随机数怎么实现

srand(time(0)); rand(); 0~32767

 

写一个二叉树翻转，然后写个测试(为了写这个测试我还白送一个二叉树层次遍历emmm)

https://blog.csdn.net/qq_29762941/article/details/80909342

测试：反转两次，再和原来的二叉树比较是否相同

 

手写堆排序，然后分析下建堆时间复杂度(从n/2开始向上建堆的话是O(n))

https://blog.csdn.net/yuzhihui_no1/article/details/44258297

 

strcpy安全性，如何实现安全，strnpy,写一下并测试，

https://blog.csdn.net/ZH___xin/article/details/51985562

 

写sql语句(A表存储有每个电话号码当月通话记录，表B是电话号码集合，求表B每个号码通话次数)，大概就是比较简单的连表查询，加count

select B.telno, count(B.telno)

 from A right join B

where A.telno = B.telno

group by B.telno

 

假设上面题中A B两个表存在文件，怎么编程统计？ 我答的使用hashmap存储电话和次数，时间复杂度呢？ 只需要扫描两个文件各一遍O(n+m)

 

两字符串最长公共子串， 最长公共子序列

https://blog.csdn.net/u012426298/article/details/82796660

打印二叉树每层最右边的节点 层序遍历 LeetCode 199

http://www.cnblogs.com/grandyang/p/4392254.html

 

手写代码 回形矩阵

顺时针回形打印矩阵的元素LeetCode 54
http://www.cnblogs.com/grandyang/p/4362675.html

判断在一个矩阵中是否存在一条包含某字符串所有字符的路径

https://blog.csdn.net/qq_21997625/article/details/84640353

 

3sum 数组中三数之和为0的所有三元组 leetcode 15

 

微信的附近的人这个功能，如果让你实现，你准备怎么做，

地理位置网格分块，存块ID，然后四叉搜索。你的经纬度换算成网格ID，同网格的人撸出来，临近网格的人撸出来，搞定。把地理位置分块，怎么把经纬度转化成网格 ID 呢。本质上就是hash

客户端固定时间发送经纬度（x,y）到服务器s，服务器存储每个登陆的用户的经纬度到表t中，表t按照经纬度分表，将地图分成一个个的小格子。当用户点击“附近的人”时，对用户（x,y）进行计算，最多一次查询其中的4个格子（子表），计算两点间距离获取结果（有点像桶排序）。性能上可以将表t替换为内存结构，容灾即可。
从实际的微信提供的功能来看，附近的人并不太多，估计是其对地图划分的格子很小。

MongoDB的LBS功能实现附近的人

 

https://www.nowcoder.com/discuss/165952?type=0&order=0&pos=414&page=1

微信小程序团队一共有 n 名成员，决定出去秋游，在海边遇到出租摩托艇的杰克马，马先生手上有 m 辆待出租的摩托艇，价格分别是 b1 、b2 ... bm;

由于习惯了微信支付，团队中每个人身上的现金都有限，分别是 a1 a2 ... an，对了，一起出门的老板还带有 S 元的团队经费，这个经费是每个人都可以使用的

那么考虑以下两个场景

场景1

团队成员都很有爱，都愿意借钱给其他同事，那么这时候团队最多能租到多少摩托艇

//贪心法；把所有的钱收集起来，按摩托艇的价格从低到高租借摩托艇

intisAll(int a[n], int b[m], intS){

                int sum=0;

                for(int i=0;i<n；++i)

                    sum+=a[i];

                sum+=S;

        sort(a,a+n);

        inti = 0;

        while(sum - m[i] > 0) {

            sum -= m[i];

            i++;

        }

        returni;

    }

场景2

团队成员都十分小气，是不愿意借钱给别人的,那么请考虑以下两个问题

//问题一 老板是否能想到一个策略，使得所有人都能租到摩托艇？

//贪心法；钱少的人租借便宜的摩托艇，补贴

public static boolean isAll(int[] n, int[] m, int S){

        if (n.length > m.length) { return false; }

        Arrays.sort(n); Arrays.sort(m);

        for (int i=0; i<n.length; i++) {

            int need = n[i] - m[i];

            if (need < 0)

            S += need;

        }

        return S >= 0;

    }

//问题二 请问给出一个策略

// - 使得整个团队租到最多的摩托艇

// - 在租到最多摩托艇的情况下，整体的支出尽量的少

//二分法+贪心

private static int n[];

    private static int m[];

    private static int S;

    public static int[] isAll(int[] n, int[] m, int S){

        Arrays.sort(n);

        Arrays.sort(m);

        Main.n = n; Main.m = m; Main.S = S;

        int l =0, r = m.length; //摩托艇的数量

        while (l < r)

        {

            int mid = l + r + 1 >> 1;

            if (can(mid)) { l = mid; }

            else { r = mid - 1; }

        }

        int ans = 0;

        for (int i=0; i<l; i++) {

            ans += m[i];

        }

        return new int[] {l, ans};

    }

 

   private static boolean can(int count) {

        int tmpS = S;

        for (int i = count-1,j = n.length-1; i>=0; i--, j--) {//让最多钱的人买最贵的摩托艇

            if (n[j] < m[i]) {

                tmpS -= (m[i] - n[j]);

            }

            if (tmpS < 0) { return false; }

        }

        return true;

    }

判断一个字符串是不是两个有序的字符串交错组成的。 Leetcode 97

编程题：递增数组中找两个数和为某个固定值。设计测试用例 Leetcode 1

给你一个数组和数组元素的个数，求平均值。

int avg(int x, int y)

{

         return (x & y) + ((x ^ y) >> 1);

}

两个非常大的数相加 Leetcode 415



