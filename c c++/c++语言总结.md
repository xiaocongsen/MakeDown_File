1.  封装可以隐藏实现细节，使得代码模块化；
    继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。
    多态则是为了实现另一个目的——接口重用！
2. c++的所谓异常机制
```c++
    throw 可以是各种类型数据
    try{
            需要处理的函数：fun(a,b);
    }
    catch(int（看抛的是什么类型的数据）e(可以跟变量，后面可以打印捕获的值)){
        错误提示；
    }
    catch(...（未知类型的异常）){
    }
```
3. 函数的重载原则： 1) 同一个作用域 2) 参数个数不同 3) 参数类型不同   4) 参数顺序不同(和返回类型没半毛钱关系) 5) 有没有const;
4. c++  静态类型转换 static_cast<double>(10)    在一个方向上可以隐式转换，在另一个方向上不可以的，就可以通过加static_cast做静态转换。发生在编译阶段，不保证后续使用的正确性（不安全），不在编译阶段和运行阶段进行检查，安全性完全由程序员决定;

        动态类型转换 dynamic_cast<目标类型>(标识符)  一种运行时的类型转化，所以要在运行时做转换判断，检查指针所指类型，然后判断这一类型是否与正在转换的类型有一种“is a"的关系。如果是，dynamic_cast返回地址，如果不是dynamic_cast返回NULL;
        重解释类型转换：reinterpret_cast<目标类型>(标识符) reinterpreter_cast，仅仅重新解释类型，但没有进行二进制的转换。
        常类型转换：const_cast<目标类型>(标识符) //目标类类型只能是const变量的 指针或者引用。 const_cast用来去除const限定

5. 引用： 给已有的变量起个别名，不同类型不能相互引用。
6. int &a = b; //等价于 int *const a = &b;（编译器进行了封装）
7. inline 避免了函数的压栈和出栈；只是给编译器一个合理的建议；
    使用场景：函数体积很小，且被频繁的调用；
8. 创建命名空间：
``` c++
    namespace 名称
    {
    }
    //命名空间嵌套命名空间：需要单个变量多次::
```
9.  浅拷贝:在没有堆空间的情况下，可以满足需求，如果有堆空间的话，容易造成double free; 多次释放；
    深拷贝:如果存在堆空间的话，要作特殊处理，即重写拷贝构造 ，一经从写，系统不再提供任何构造函数；
10. 形参列表：效率高,初始化时按类里面的参数排列循序初始化的，不是按形参列表的循序初始化的；
11. 3种继承方式：public  protected  private ;不会限制子类的任何成员的访问方式；会影响父类中的元素被已成到子类中的访问方式； 继承方式指定了派生类成员以及类外对象对于从基类来的成员的访问权限；
        共有继承：基类的共有成员和保护成员在派生中保持原有访问属性，其私有成员任为基类的私有成员。
        私有继承：基类的共有成员和保护成员在派生中成了私有成员，其私有成员任为基类私有成员。
        保护继承：基类的公有成员和保护成员在派生中成了保护成员。其私有成员任为基类的私有成员。
12. 虚函数：
    1.在基类中用virual声明成员函数为虚函数，类外实现虚函数时，不必再加virual。
    2.在派生类中重新定义此函数称为复写，需要函数名 返回类型 函数参数个数 及类型全部匹配，并根据派生类的需要重新定义函数体。
    3.当一个成员函数声明为虚函数后，其派生类中完全相同的函数（显示的写出）也为虚函数。可以在其前加virtual一示清晰。
    4.定义一个指向基类对象的指针，并使其指向其子类的对象，通过该指针调用虚函数。此时调用的就是指针变量指向对象的同名函数。
    5.子类中覆写的函数，可以为任意访问类型，依子类需要决定。
13. 运算符typeid 返回包含操作数类型信息的type_info对象的一个引用。信息中包括数据类型名称，要使用typeid,程序中需要添加头文件<typeinfo>.   它中重载了操作符 == ，！=， =分别用来比较是否相等，不等，赋值。函数name()返回类型名称。 常用于返回检测调试之用。
14. 纯虚函数：
    1.含有纯虚函数的类，称为抽象基类，不可实例化。既不能创建对象。存在的意义就是被继承，提供族类的公共接口,java中称为 interface.
    2.纯虚函数只有声明，没有实现，被“初始化”为0。
    3.如果一个类中声明了纯虚函数，而在派生类中没有对该函数定义，则该虚函数在派生类中任然为虚函数。派生类任然为虚基类；
15. 函数模板，只适用于函数的参数个数相同而类型不同，且函数体相同的情况，如果个数不同，则不能用函数模板 模板的成员函数要么在模板类实现，在模板外实现的话需要加template<typename T> ,成员函数从前是加类信息(A::)，现在是加模板信息(A<T>::)
16. c++文件
``` c++
刷新缓冲区
cout<<"asfdsadfs"<<endl;
cout<<"sdfsdafasd<<"flush;
cout<<unitbuf<<"dsfasfasd";
//都重载了<<操作符 
fstream fs("aa.txt",ios::out | ios::in | ios::trunc);

cin.get( 存储地址,个数，"结束字符"）
cin.ignore(1)//跳过一个字符。
cin.getline(存储地址，个数，（默认回车）"结束符"）//和cin.get的区别有默认 ’\n' ，getline遇到结束标记会跳过这个字符再结束，get遇到结束标记会直接返回，需要手动跳过。
cin.ignore(n,终止字符）//跳过流中的n个字符，或遇到终止字符为止（包含）。默认参数为忽略一个字符。
cin.peek(); //只是窥视当前位置的内容，返回为这个字符，（当前的指针没有发生移动，还是在原来的位置）。
cin.putback(); // 回推， （放回原来的地方 ）插入当前指针位置。

#include< fstream >
ifstream ifile;//定义一个文件输入流对象；默认ios::in.
ofstream ifile;//定义一个文件输出流对象；默认ios::out | ios::trunc
fstream iofile;//定义一个文件输出/输入流对象；ios::int | ios::out | ios::app

ios::in | ios::out  //表示以读/写方式打开文件；
ios::in | ios::binary  //表示以二进制读方式打开文件
ios::out | ios::binary  //表示以二进制写方式打开文件
ios::in | ios::out | ios binary 表示以二进制读/写方式打开文件
参数： 
ios::in // r
ios::out// w
ios::app// a
ios::trunc //w
ios::binary // rb
标志位：
cin.eof()//结束符.
cin.fail() //判断结束，判断错误 
cin.bad()
cin.good()
//当对流对象，完成一次操作以后。流对象中的标志位就会置位，我们就可以通过标记位来判断当前流的状态。
```