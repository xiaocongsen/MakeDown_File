# 汇编学习

## 二进制的简写

0000    0001    0010    0011    0100    0101    0110    0111    1000    1001    1010    1011    1100    1101    1111
0       1       2       3       4       5       6       7       8       9       A       B       C       D       E

## 无符号和有符号

    无符号的原码反码补码都是一样的
    有符号的内存中存储的是补码
    例如：-106
    源码：1001 0110
    反码：1110 1001
    补码：1110 1010     反码+1
    内存中存储的就是EA

## 位操作

### 按位与

    汇编指令and

    c语言符合 &
> 可以理解成串联电路

- 0 and 0 = 0
- 1 and 0 = 0
- 0 and 1 = 0
- 1 and 1 = 1

### 按位或

    汇编指令 or

    c语言符号 |
> 可以理解成并联电路

- 0 or 0 = 0
- 1 or 0 = 1
- 0 or 1 = 1
- 1 or 1 = 1

### 按位异或

    汇编指令xor

    c语言符号 ^
> 可以理解成交叉电路=x= 同为0，异为1

- 0 xor 0 = 0
- 1 xor 0 = 1
- 0 xor 1 = 1
- 1 xor 1 = 0

### 非(取反)

    汇编指令not

    c语言符号 ~

- not 1 = 0
- not 0 = 1

### 左移

汇编指令 shl

c语言符号 <<
> 高位丢弃，低位补零

- shl 11011000, 2    得到 0110 0000

### 右移

无符号的汇编指令 shr

有符号的汇编指令 sar

c语言符号 >>
> 低位丢弃，高位补零或补符号位

- shr 11011000, 2   得到 0011 0110
- sar 11011000, 2   得到 1111 0110

### 非与门

一个字节8位的计算

- 11111111 NAND 000000001 = 11111110
- 11111111 NAND 100000000 = 01111111
- 11111111 NAND 111111111 = 00000000
- 00000000 NAND 000000000 = 11111111

### 非或门

一个字节8位的计算

- 11111111 NOR 000000001 = 00000000
- 11111111 NOR 100000000 = 00000000
- 11111111 NOR 111111111 = 00000000
- 00000000 NOR 000000000 = 11111111

## 计算机的加减乘除

### 加法

例如：    4+5

1. xor 00000100,00000101  得到 0000 0001
2. and 00000100,00000101  得到 0000 0100 非零则继续
3. shl 00000100,1         得到 0000 1000
4. xor 00000001,00001000  得到 0000 1001
5. and 00000001,00001000  得到 0000 0000 为零结束,得到值为00001001

### 减法

例如：    4-5 ==  4+(-5)

1. xor 00000100,11111011 得到 1111 1111
2. and 00000100,11111011 得到 0000 0000 为零结束，得到值为1111 1111

### 乘法

x*y 本质就是加法 y个x相加

### 除法

x/y 本质就是减法 x能减去多少个y

## x86或x64架构的CPU的汇编指令

    r       通用寄存器
    m       代表内存
    imm     代表立即数
    r8      代表8位通用寄存器
    m8      代表8位内存
    imm8    代表8位立即数

### mov

    将数据从一个位置传送到另一个位置。

1. mov r/m8,r8
2. mov r/m16,r16
3. mov r/m32,r32
4. mov r8,r/m8
5. mov r16,r/m16
6. mov r32,r/m32
7. mov r8,imm8
8. mov r16,imm16
9. mov r32,imm32

- 例子：

    ```asm
        mov eax,1
    ```

### ADD

    将两个数相加并将结果存储在指定的位置。例如：ADD AX, BX 将AX和BX中的值相加，结果存储在AX寄存器中。

1. ADD r/m8,imm8
1. ADD r/m16,imm16
1. ADD r/m32,imm32
1. ADD r/m16,imm8
1. ADD r/m32,imm8
1. ADD r/m8,r8
1. ADD r/m16,r16
1. ADD r/m32,r32
1. ADD r8,r/m8
1. ADD r16,r/m16
1. ADD r32,r/m32

### SUB

    从一个数中减去另一个数并将结果存储在指定的位置。例如：SUB AX, BX 将BX的值从AX中减去，结果存储在AX寄存器中。

1. SUB r/m8,imm8
1. SUB r/m16,imm16
1. SUB r/m32,imm32
1. SUB r/m16,imm8
1. SUB r/m32,imm8
1. SUB r/m8,r8
1. SUB r/m16,r16
1. SUB r/m32,r32
1. SUB r8,r/m8
1. SUB r16,r/m16
1. SUB r32,r/m32

### AND / OR

    对两个值进行按位逻辑与/或操作。例如：AND AX, BX 将AX和BX中的值进行按位与操作，结果存储在AX寄存器中。

1. AND / OR r/m8,imm8
1. AND / OR r/m16,imm16
1. AND / OR r/m32,imm32
1. AND / OR r/m16,imm8
1. AND / OR r/m32,imm8
1. AND / OR r/m8,r8
1. AND / OR r/m16,r16
1. AND / OR r/m32,r32
1. AND / OR r8,r/m8
1. AND / OR r16,r/m16
1. AND / OR r32,r/m32

### XOR

    对两个值进行按位异或操作。例如：XOR AX, BX 将AX和BX中的值进行按位异或操作，结果存储在AX寄存器中。

1. XOR r/m8,imm8
1. XOR r/m16,imm16
1. XOR r/m32,imm32
1. XOR r/m16,imm8
1. XOR r/m32,imm8
1. XOR r/m8,r8
1. XOR r/m16,r16
1. XOR r/m32,r32
1. XOR r8,r/m8
1. XOR r16,r/m16
1. XOR r32,r/m32

### NOT

    对一个值进行按位取反操作。例如：NOT CX 对CX寄存器中的值进行按位取反操作。

1. NOT r/m8
2. NOT r/m16
3. NOT r/m32

### MOVS/MOVSB/MOVSW/MOVSD

    移动数据 内存到内存

- 例子：

    ```asm
        //注意下一个地址是加还是减 受到方向位DF位的控制，DF=0为加 DF=1为减
        mov EDI,12FFD8
        mov ESI,12F0D0
        //简写MOVSB 固定使用EDI和ESI 执行成功后EDI和ESI将指向下一个BYTE地址
        //执行成功后 DF=0 EDI=12FFD9 ESI=12F0D1
        //DF=1 EDI=12FFD7 ESI=12F0CF
        movs BYTE PTR ES:[EDI], BYTE PTR DS:[ESI]
        //简写MOVSW 固定使用EDI和ESI 执行成功后EDI和ESI将指向下一个WORD地址
        movs WORD PTR ES:[EDI], WORD PTR DS:[ESI]
        //简写MOVSD 固定使用EDI和ESI 执行成功后EDI和ESI将指向下一个DWORD地址
        movs DWORD PTR ES:[EDI], DWORD PTR DS:[ESI]
    ```

### STOS/STOSB/STOSW/STOSD

    将寄存器AI/AX/EAX的值存储到[EDI]指定的内存单元

- 例子：

    ```asm
        //注意下一个地址是加还是减 受到方向位DF位的控制，DF=0为加 DF=1为减
        mov EAX,1243D0
        mov EDI,12FFD8
        //简写STOSB 固定使用EDI和ESI 执行成功后EDI将指向下一个BYTE地址
        //执行成功后 DF=0 EDI=12FFD9 
        //DF=1 EDI=12FFD7 
        STOS BYTE PTR ES:[EDI]
        //简写STOSW 固定使用EDI和ESI 执行成功后EDI将指向下一个WORD地址
        STOS WORD PTR ES:[EDI]
        //简写STOSD 固定使用EDI和ESI 执行成功后EDI将指向下一个DWORD地址
        STOS DWORD PTR ES:[EDI]
        
    ```

### REP

    重复执行指定的操作。

- 例子：

    ```asm
        //将MOVSB指令重复执行16次。
        mov ECX,10
        REP MOVSB
        //执行完成后 ECX就为0了
    ```

### PUSH

    将一个值压入堆栈中，并修改ESP寄存器的指针

1. PUSH r32
1. PUSH r16
1. PUSH m16
1. PUSH m32
1. PUSH imm8/imm16/imm32

### POP

    将堆栈顶部的值弹出。例如：POP EAX 弹出堆栈顶部的值，并将其存储在EAX寄存器中。 

1. POP r32
1. POP r16
1. POP m16
1. POP m32

### JMP

    无条件跳转到指定的位置,就是通过修改EIP寄存器的值来实现跳转。例如：JMP LABEL 跳转到名为LABEL的标签所在的位置。

1. JMP r32
1. JMP m32
1. JMP imm32

### CALL

    调用一个子程序。例如：CALL SUBROUTINE 调用名为SUBROUTINE的子程序。
    本质是修改EIP，PUSH下一行指令地址(包含压栈和ESP减4)

1. CALL r32
1. CALL m32
1. CALL imm32

### RET

    返回子程序的调用点。例如：RET 返回到上一个CALL指令所在的位置。
    本质是POP出栈顶的值到EIP里,如果时RET 4则是POP出栈顶的值到EIP里并将ESP+4

### CMP

    本质是比较两个操作数的大小，可以将其视为SUB指令的变种，但是不会修改第一个操作数的值。
    CMP指令会将第一个操作数减去第二个操作数，如果计算结果为0，则设置ZF位为1。如果结果为负数，则SF被设置为1且CF也被设置为1。

### TEST

    本质是进行逻辑与(AND)运算，即对两个操作数进行按位AND运算，并设置标志位。且不涉及对操作数的修改，只是通过按位运算来影响标志位。
    如果结果是0，则标志位ZF位为1。如果结果的最高位为1，SF标志位被设置为1。且不管结果如何，CF标志位会都会被清零

### JCC指令

1. JE,JZ       结果为零则跳转(相等时跳转)               ZF=1
1. JNE,JNZ     结果不为零则跳转(不相等时跳转)           ZF=0
1. JS          结果为负则跳转                          SF=1
1. JNS         结果为非负则跳转                        SF=0
1. JP,JPE      结果中1的个数为偶数则跳转                PF=1
1. JNP,JPO     结果中1的个数为偶数则跳转                PF=O
1. JO          结果溢出了则跳转                        OF=1
1. JNO         结果没有溢出则跳转                      OF=0
1. JB,JNAE     小于则跳转(无符号数)                    CF=1
1. JNB,JAE     大于等于则跳转(无符号数)                 CF=O
1. JBE,JNA     小于等于则跳转(无符号数)                 CF=1 or ZF=1
1. JNBE,JA     大于则跳转(无符号数)                     CF=0 and ZF=0
    - 例子：

        ```asm
           mov al,0FF
           mov cl,1
           cmp al,cl
           ja 418408        //是无符号数 al大于cl
        ```

1. JL,JNGE     小于则跳转(有符号数)                     SF!=OF
1. JNL,JGE     大于等于则跳转(有符号数)                 SF=OF
1. JLE,JNG     小于等于则跳转(有符号数)                 ZF=1 or SF!=OF
1. JNLE,JG     大于则跳转(有符号数)                     ZF=0 and SF=OF
    - 例子：

        ```asm
           mov al,0FF
           mov cl,1
           cmp al,cl
           jg 418408        //是有符号数 al小于cl
        ```

MOVZX 操作码表示无符号扩展传送，它的语法为  movzx dest, src，其中 dest 表示目标操作数，src 表示源操作数。

imul: 乘法运算, 列如：imul eax, ebp  eax的值乘以ebp的值,并将结果存储到eax寄存器中。
mul:  无符号整数相乘, 它的语法是 mul operand，其中 operand 是要乘的操作数。mul 指令的具体行为取决于操作数的大小。例如，如果操作数是 8 位无符号整数，那么 mul 指令会将 AX 寄存器中的值乘以操作数，并将结果存储在 DX:AX 中。如果操作数是 16 位无符号整数，那么 mul 指令会将 DX:AX 中的值乘以操作数，并将结果存储在 DX:AX 中。如果操作数是 32 位无符号整数，那么 mul 指令会将 EDX:EAX 中的值乘以操作数，并将结果存储在 EDX:EAX 中。在执行 mul 操作之前，应该将被乘数存储在适当的寄存器中。

### div

> 用于执行除法运算。可以将两个无符号整数除法。它会将一个32位的被除数(在EDX:EAX中)除以一个32位的除数(在ECX中)，并将商存储在EAX中，将余数存储在EDX中。需要注意的是，如果除数为0或者商无法存储在32位寄存器中，div指令会导致除法错误。

- 例子：

    ``` asm
    mov edx, 0      ; 将EDX清零
    mov eax, 100    ; 将被除数存储在EAX中
    mov ecx, 5      ; 将除数存储在ECX中
    div ecx         ; 将EDX:EAX除以ECX，将商存储在EAX中，余数存储在EDX中
    ```

JZ / JE：当零标志位为1时跳转到指定位置，通常用于条件分支语句中。例如：JZ LABEL 如果零标志位为1，则跳转到名为LABEL的标签所在的位置。
JL / JB：当进位标志位或符号标志位为1时跳转到指定位置，通常用于条件分支语句中。例如：JL LABEL 如果符号标志位为1，则跳转到名为LABEL的标签所在的位置。

INT：触发一个中断。例如：INT 21h 触发21h号中断，用于调用操作系统的功能。
LOOP：循环执行指定的操作。例如：LOOP LABEL 循环执行名为LABEL的标签所在的位置，CX寄存器自动减一。
INC：将一个值加一。例如：INC AX 将AX中的值加一。
DEC：将一个值减一。例如：DEC BX 将BX中的值减一。
LEA：计算一个内存地址，并将其存储到寄存器中。例如：LEA BX, [SI+10] 将DS:SI+10处的内存地址计算出来，并将其存储到BX寄存器中。
SHL / SHR：将一个值向左或向右移位。例如：SHL AX, 1 将AX中的值向左移动一位。
TEST：对两个值进行按位与操作，并设置标志位。例如：TEST AX, BX 将AX和BX中的值进行按位与操作，并设置标志位以指示它们的相对大小。

CWD / CDQ：将AX或EAX中的值扩展为一个有符号数。例如：CWD 将AX中的值扩展为一个有符号数并存储到DX中。
CLC / STC：清除或设置进位标志位。例如：CLC 清除进位标志位。
CLI / STI：关闭或打开中断。例如：CLI 关闭中断。
REPNE / REPNZ：重复执行指定的操作，直到标志位不满足。例如：REPNE SCASB 将SCASB指令重复执行CX次，直到ZF标志位不满足。
LDS / LES：加载一个指针，并将其存储到指定的寄存器中。例如：LDS DX, [BX] 将DS:[BX]中的指针加载到DS中，并将偏移量加载到DX寄存器中。
JG / JA：当大于标志位或进位标志位为0时跳转到指定位置，通常用于条件分支语句中。例如：JG LABEL 如果ZF标志位为0且SF标志位和OF标志位相同，则跳转到名为LABEL的标签所在的位置。
JNZ/JNE 指令是x86汇编语言中的条件跳转指令，它代表“如果非零则跳转”，也称为指令(如果不相等则跳转)。通过检查处理器状态寄存器中的零标志位(ZF)来决定是否跳转到另一个内存地址，如果ZF标志位被清零(值为0)，则JNZ跳转到指定的内存地址；否则，如果ZF标志位被设置(值为1)，则JNZ继续按顺序执行下一条指令。例如：CMP AX, BX 比较AX和BX中的值，如果AX和BX的值不相等 就跳转

proc near  函数定义部分,列如:sub_401000      proc near     函数名称(sub_401000)
var_1  = byte ptr -1   解释：var_1被定义为一个字节(byte)类型的变量，位于函数栈中距离当前EBP寄存器位置-1个字节的位置,[ebp+var_1]这样可以访问这个变量
arg_0  = dword ptr  8  解释：arg_0则被定义为一个双字(dword)类型的变量，位于函数栈中距离当前EBP寄存器位置8个字节的位置,[ebp+arg_0]这样可以访问这个变量

RETN 0xC 指令表示从堆栈中弹出 0xC 个字节的数据，并将堆栈指针向上移动相应的字节数。如果没有指定操作数，则默认情况下弹出 4 个字节的返回地址。

## 寄存器

    不能将大的寄存器存入小的寄存器中

### 8位通用寄存器

AL  AX的低8位
CL  CX的低8位
DL  DX的低8位
BL  BX的低8位
AH  AX的高8位
CH  CX的高8位
DH  DX的高8位
BH  BX的高8位

### 16位通用寄存器

AX  EAX的低16位
CX  ECX的低16位
DX  EDX的低16位
BX  EBX的低16位
SP  ESP的低16位
BP  EBP的低16位
SI  ESI的低16位
DI  EDI的低16位

### 32位通用寄存器

EAX 是 x86 CPU 中的一个 32 位通用寄存器，它可以用于存储数据或指向内存地址，还可以用于进行算术和逻辑运算，作为函数调用的返回值寄存器等。通常用于存储函数的返回值。在函数执行完成后，返回值将存储在 EAX 寄存器中，并通过 RET 指令返回给调用方。

ECX 是 x86 CPU 中的一个 32 位通用寄存器，与 EAX 寄存器类似，它可以用于存储数据或指向内存地址，还可以用于进行算术和逻辑运算。通常被用于循环计数器。在一些情况下，ECX 可以用于存储需要频繁使用的数据，以便快速访问。在 Windows 操作系统中，ECX 可以用于存储函数调用的参数。

EDX 是 x86 CPU 中的一个 32 位通用寄存器，它和 EAX 和 ECX 寄存器一样，在汇编语言中经常被用于进行算术和逻辑运算。但 EDX 还有其他的一些特殊用途。被用作除法运算的余数寄存器。在进行除法运算时，商会存储在 EAX 中，余数会存储在 EDX 中。在 Windows 操作系统中，EDX 寄存器通常用于存储一些操作系统调用的参数，例如文件 I/O 操作的文件句柄和缓冲区长度等。

EBX 是 x86 CPU 中的一个 32 位通用寄存器，它和 EAX、ECX 和 EDX 寄存器一样，在汇编语言中经常被用于进行算术和逻辑运算。但是 EBX 还有其他的一些特殊用途。被用作一些重要的指针寄存器，例如存储地址或指向数据的指针等。在 Windows 操作系统中，EBX 寄存器经常用于存储一些重要的参数或指针，例如传递函数参数或访问数据结构的指针。

ESP 是 x86 架构下的寄存器，代表堆栈指针.在 x86 架构中，堆栈通常从高地址向低地址生长，所以指向压入的当前元素 一定是小于等于栈底

EBP 是 x86 CPU 中的一个 32 位寄存器，通常被用作堆栈帧指针，在函数调用时用于保存栈帧的起始地址。在函数调用时，EBP 被压入栈中，然后被设置为当前栈帧的起始地址，通常指向当前函数的栈帧底部。EBP 还可以用于在调用函数时保存返回地址。返回地址通常保存在当前函数的栈帧顶部，因此可以通过将 EBP 值减去返回地址所在的偏移量来获取返回地址。

ESI 是 x86 CPU 中的一个 32 位寄存器，用于存储源数据的地址。在一些字符串和数组处理操作中，ESI 被广泛用于存储源数据的起始地址和遍历源数据。ESI 通常用于存储指向数组、字符串或其他连续数据结构的指针。

EDI 类似于ESI

### 专用寄存器

EIP 是所有x86CPU中都存在的寄存器，代表指令指针.指令指针是一个特殊的寄存器，用于存储 CPU 执行下一条指令的地址。还可以用于其他用途 实现分支跳转和条件跳转等控制结构，以及实现异常处理和中断处理等机制。在实际编程中，程序员通常使用汇编语言或编译器生成的机器码来直接修改 EIP 寄存器的值，以实现跳转和分支等操作。

### EFL寄存器

> 是x86架构中的标志寄存器，包含了当前程序运行状态的标志位信息

#### CF(Carry Flag)

    进位标志,在执行加减法操作时，如果最高位进位或借位，CF标志会被设置为1，否则为0。
    主要是无符号数运算,如果溢出看CF是否为1

- 例子：

    ``` asm
        //进位
        MOV AL,0xFE         //如果0xFE是有符号数则cf位无用，如果是无符号数执行add后可以看cf位来判断是否溢出
        ADD AL,2            
        //借位
        MOV AL,0x7F
        SUB AL,0xFF
    ```

#### PF(Parity Flag)

    奇偶标志,该标志用于表示指令结果的二进制位数中最低有效位包含1的个数是否为偶数。如果是偶数则PF标志为1，否则为0。
    只统计最后一位中1的个数，通过PF可以进行奇偶校验的检测

- 例子：

    ``` asm

        MOV AL,0CE          
        ADD AL,0            //加0 后检测PF是否变化
    ```

### AF(Auxiliary Carry Flag)

    辅助进位标志，在执行加减法操作时，如果第3位进位或借位，AF标志会被设置为1，否则为0。
    这个标志在BCD算数运算中被使用

- 例子：

    ``` asm
        mov eax,0x55EEFFFF
        add eax,2

        mov ax,5EFE 
        add eax,2

        mov al,4E
        add al,2
    ```

### ZF(Zero Flag)

    零标志,如果指令执行结果为0，ZF标志被设置为1，否则为0。
    经常与CMP或者TEST等指令一起使用。

- 例子：

    ``` asm
        mov eax, 100
        mov ecx, 100
        cmp eax, ecx        //ZF=1
    ```

### SF(Sign Flag)

    符号标志,如果指令执行结果为负数，SF标志被设置为1，否则为0。
    主要正对有符号数，存储的是运算结果最高位的值。

- 例子：

    ``` asm
        mov al, 0x7F
        Add al, 2        //SF=1

        mov al, 0xFE
        add al, 2       //SF=1
    ```

### TF(Trap Flag)

    陷阱标志(单步标志): 该标志用于单步执行调试程序，如果TF标志被设置为1，CPU执行每一条指令后都会触发一次中断，以便调试程序检查执行结果。

### IF(Interrupt Flag)

    中断标志,该标志用于控制中断的响应，如果IF标志被设置为1，CPU可以响应中断请求，否则禁止中断响应。

### DF(Direction Flag)

    方向标志,该标志用于控制字符串操作的方向，如果DF标志被设置为1，字符串操作将从高地址向低地址进行就是减，否则从低地址向高地址进行就是加。
    影响的指令有MOVS,CMPS,SCAS,LODS,STOS, 指向栈的下一个地址是加还是减 受到方向位DF位的控制，DF=0为加 DF=1为减。
    STD指令用于设置DF标志,CLD指令用于清理DF标志。

### OF(Overflow Flag)

    溢出标志，在执行加减法操作时，如果结果溢出，则OF标志会被设置为1，否则为0。
    主要是有符号数运算,如果溢出看OF是否为1

- 例子：

    ``` asm
        mov al,0x7F         //如果0x7F是无符号数则Of位无用，如果是有符号数执行add后可以看of位来判断是否溢出
        add al,2             //OF=1
    ```

### RF(Resume Flag)

    恢复标志,该标志用于控制中断的恢复，如果RF标志被设置为1，CPU会忽略中断请求，否则会响应中断请求。

### VM(虚拟模式标志位，Virtual-8086 Mode Flag)

    用于控制CPU是否进入虚拟8086模式。当VM=0时，CPU处于保护模式下；当VM=1时，CPU进入虚拟8086模式，可以运行MS-DOS等16位应用程序。

### AC(辅助进位标志位，Auxiliary Carry Flag)

    用于协助处理二进制运算中的进位问题。当两个4位二进制数相加时，如果第4位有进位，则AC=1，否则AC=0。

### ID(CPU识别标志位，Identification Flag)

    用于区分CPU支持的指令集。当ID=1时，表示CPU支持CPUID指令，可以查询CPU的基本信息。

> 寄存器EFL是32位寄存器，其中每个位都代表着不同的标志位

1. 第0位：CF(Carry Flag)，进位标志位；
1. 第2位：PF(Parity Flag)，奇偶标志位；
1. 第4位：AF(Adjust Flag)，辅助进位标志位；
1. 第6位：ZF(Zero Flag)，零标志位；
1. 第7位：SF(Sign Flag)，符号标志位；
1. 第8位：TF(Trap Flag)，单步标志位；
1. 第9位：IF(Interrupt Flag)，中断允许标志位；
1. 第10位：DF(Direction Flag)，方向标志位；
1. 第11位：OF(Overflow Flag)，溢出标志位

- 除了以上标志位之外，EFL寄存器还有一些保留位和系统位，其中保留位是不使用的，系统位用于处理器内部操作。这些保留位和系统位在不同的CPU架构中可能会有所不同。

### 调试寄存器

调试寄存器是一组专门用于调试的CPU寄存器，通常被称为“调试寄存器”、“调试寄存器组”或“D寄存器组”。调试寄存器允许程序员在程序执行期间监视和调试程序，以及在需要时强制暂停程序的执行。常见的调试寄存器包括以下几种：

- DR0~DR3：数据断点寄存器，用于设置数据访问断点。每个数据断点寄存器可以设置一个断点地址，当访问该地址时，程序会停止执行。

- DR6：调试寄存器状态寄存器，用于指示触发了哪些断点。每个断点都会在DR6中设置一个位，程序员可以通过读取DR6来确定是哪个断点触发了中断。

- DR7：断点控制寄存器，用于控制数据断点和指令断点。可以设置每个数据断点和指令断点是否启用、触发条件和断点类型等属性。

调试寄存器的使用可以提高程序调试的效率和精度，但需要注意的是，不正确地使用调试寄存器可能会导致程序崩溃或产生不可预测的结果。因此，程序员在使用调试寄存器时需要谨慎，并且需要对底层硬件和操作系统有深入的了解。

### 内存

    大部分指令都不能从内存写到内存，必须经过寄存器

#### 写入大小指令

    BYTE    1字节
    WORD    2字节
    DWORD   4字节

    ```asm
        //读取内存值
        MOV EAX,DWORD PTR DS:[0x13ddc4]
        //向内存中写入数据
        MOV DWORD PTR DS:[0x13ddc4],ECX
    ```

#### 读写内存的5种形式

1. 直接写入立即数

    ```asm
        MOV 1,DWORD PTR DS:[0x13ddc4]
    ```

2. 填写寄存器的形式,只能是32位的8个通用寄存器

    ```asm
        MOV EAX,0x13FFD0
        MOV DWORD PTR DS:[EAX],1
        //如果使用的寄存器是ESP和EBP是 MOV DWORD PTR SS:[ESP], 1    
        //当使用SS:[ESP]操作内存时，CPU将使用SS寄存器中的值作为段地址，ESP寄存器中的值作为偏移地址，以计算出正确的内存地址。这是因为栈中的数据通常是由程序动态压入或弹出的，如果不使用SS寄存器，就无法正确地访问栈中的数据。
    ```

3. 寄存器加立即数的形式

    ```asm
        MOV EAX,0x13FFD0
        MOV 1,DWORD PTR DS:[EAX+4]
    ```

4. 寄存器加寄存器*{1,2,4,8} --数组生成的形式

    ```asm
        MOV EAX,13FFC4
        MOV ECX,2
        MOV DWORD PTR DS:[EAX+ECX*8],1
    ```

5. 寄存器加寄存器*{1,2,4,8}再加立即数

    ```asm
        MOV EAX,13FFC4
        MOV ECX,2
        MOV DWORD PTR DS:[EAX+ECX*8+4],1
    ```

### 存储模式

    x86绝大部分是小端存储，arm绝大部分是大端存储，网络协议中规定了网络数据使用大端模式
    ``` asm
        mov word ptr ds:[0x00000000], 0x1A2C
    ```

#### 大端模式

    0x00000000  1A      数据的高位在低位
    0x00000001  2C      数据的低位在高位

#### 小端模式

    0x00000000  2C      数据的低位在低位
    0x00000001  1A      数据的高位在高位

#### 命令查看内存窗口

    db 18ff9c       按一个字节显示的查看
    dw 18ff9c       按两个字节显示的查看
    dd 18ff9c       按四个字节显示的查看

### 什么是堆栈平衡

1. 如果要返回父程序，则当我们在堆栈中进行堆栈的操作的时候，一定要保证在RET这条指令之前，ESP指向的是我们调用函数时压入栈中的地址
2. 如果通过堆栈传递参数了，那么在函数执行完毕后，要平衡参数导致的堆栈变化。在函数执行完后修改ESP的方法叫外平栈，在函数RET n时平衡的方法叫内平栈

### EBP寻址

    方便查找使用传入参数

- 例子：

    ``` asm
        004BE2D2        push 0x1                            //压入参数1
        004BE2D4        push 0x2                            //压入参数2
        004BE2D6        call 第五课课.004BE2DD              //调用函数 压入004BE2DB到栈
        004BE2DB        retn
        004BE2DC        nop
        004BE2DD        push ebp                            //压入ebp的值 保存起来
        004BE2DE        mov ebp,esp                         //修改ebp的值到当前esp的位置
        004BE2E0        sub esp,0x10                        //预分配0x10个空间
        004BE2E3        mov eax,dword ptr ss:[ebp+0x8]      
        004BE2E6        add eax,dword ptr ss:[ebp+0xC]
        004BE2E9        mov esp,ebp                         //还原预分配的空间
        004BE2EB        pop ebp                             //还原ebp的位置
        004BE2EC        retn 0x8                            //弹出栈并修改eip为004BE2DB，并弹出0x8个字节的栈空间实现堆栈平衡


    ```

