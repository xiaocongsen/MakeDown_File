# x86或x64架构的CPU的汇编指令

MOV：将数据从一个位置传送到另一个位置。例如：MOV AX, BX 将BX的值传送到AX寄存器中。
MOVZX 操作码表示无符号扩展传送，它的语法为 movzx dest, src，其中 dest 表示目标操作数，src 表示源操作数。
ADD：将两个数相加并将结果存储在指定的位置。例如：ADD AX, BX 将AX和BX中的值相加，结果存储在AX寄存器中。
SUB：从一个数中减去另一个数并将结果存储在指定的位置。例如：SUB AX, BX 将BX的值从AX中减去，结果存储在AX寄存器中。
imul: 乘法运算, 列如：imul eax, ebp  eax的值乘以ebp的值,并将结果存储到eax寄存器中。
JMP：无条件跳转到指定的位置。例如：JMP LABEL 跳转到名为LABEL的标签所在的位置。
JZ / JE：当零标志位为1时跳转到指定位置，通常用于条件分支语句中。例如：JZ LABEL 如果零标志位为1，则跳转到名为LABEL的标签所在的位置。
JL / JB：当进位标志位或符号标志位为1时跳转到指定位置，通常用于条件分支语句中。例如：JL LABEL 如果符号标志位为1，则跳转到名为LABEL的标签所在的位置。
AND / OR：对两个值进行按位逻辑与/或操作。例如：AND AX, BX 将AX和BX中的值进行按位与操作，结果存储在AX寄存器中。
XOR：对两个值进行按位异或操作。例如：XOR AX, BX 将AX和BX中的值进行按位异或操作，结果存储在AX寄存器中。
CALL：调用一个子程序。例如：CALL SUBROUTINE 调用名为SUBROUTINE的子程序。
RET：返回子程序的调用点。例如：RET 返回到上一个CALL指令所在的位置。
PUSH：将一个值压入堆栈中。例如：PUSH AX 将AX中的值压入堆栈中。
POP：将堆栈顶部的值弹出。例如：POP AX 弹出堆栈顶部的值，并将其存储在AX寄存器中。
MOVSB / MOVSW：将一个字节或一个字从一个位置复制到另一个位置。例如：MOVSB 将一个字节从DS:SI所指向的位置复制到ES:DI所指向的位置。
INT：触发一个中断。例如：INT 21h 触发21h号中断，用于调用操作系统的功能。
LOOP：循环执行指定的操作。例如：LOOP LABEL 循环执行名为LABEL的标签所在的位置，CX寄存器自动减一。
INC：将一个值加一。例如：INC AX 将AX中的值加一。
DEC：将一个值减一。例如：DEC BX 将BX中的值减一。
NOT：对一个值进行按位取反操作。例如：NOT CX 对CX寄存器中的值进行按位取反操作。
LEA：计算一个内存地址，并将其存储到寄存器中。例如：LEA BX, [SI+10] 将DS:SI+10处的内存地址计算出来，并将其存储到BX寄存器中。
REP：重复执行指定的操作。例如：REP MOVSB 将MOVSB指令重复执行CX次。
SHL / SHR：将一个值向左或向右移位。例如：SHL AX, 1 将AX中的值向左移动一位。
TEST：对两个值进行按位与操作，并设置标志位。例如：TEST AX, BX 将AX和BX中的值进行按位与操作，并设置标志位以指示它们的相对大小。
STOSB / STOSW：将一个字节或一个字写入到指定的内存位置。例如：STOSB 将AL中的值写入到ES:DI所指向的位置。
CWD / CDQ：将AX或EAX中的值扩展为一个有符号数。例如：CWD 将AX中的值扩展为一个有符号数并存储到DX中。
CLC / STC：清除或设置进位标志位。例如：CLC 清除进位标志位。
CLI / STI：关闭或打开中断。例如：CLI 关闭中断。
REPNE / REPNZ：重复执行指定的操作，直到标志位不满足。例如：REPNE SCASB 将SCASB指令重复执行CX次，直到ZF标志位不满足。
LDS / LES：加载一个指针，并将其存储到指定的寄存器中。例如：LDS DX, [BX] 将DS:[BX]中的指针加载到DS中，并将偏移量加载到DX寄存器中。
JG / JA：当大于标志位或进位标志位为0时跳转到指定位置，通常用于条件分支语句中。例如：JG LABEL 如果ZF标志位为0且SF标志位和OF标志位相同，则跳转到名为LABEL的标签所在的位置。
JNZ/JNE 指令是x86汇编语言中的条件跳转指令，它代表“如果非零则跳转”，也称为指令（如果不相等则跳转）。通过检查处理器状态寄存器中的零标志位（ZF）来决定是否跳转到另一个内存地址，如果ZF标志位被清零（值为0），则JNZ跳转到指定的内存地址；否则，如果ZF标志位被设置（值为1），则JNZ继续按顺序执行下一条指令。例如：CMP AX, BX 比较AX和BX中的值，如果AX和BX的值不相等 就跳转



proc near  函数定义部分,列如:sub_401000      proc near     函数名称（sub_401000）
var_1  = byte ptr -1   解释：var_1被定义为一个字节（byte）类型的变量，位于函数栈中距离当前EBP寄存器位置-1个字节的位置,[ebp+var_1]这样可以访问这个变量
arg_0  = dword ptr  8  解释：arg_0则被定义为一个双字（dword）类型的变量，位于函数栈中距离当前EBP寄存器位置8个字节的位置,[ebp+arg_0]这样可以访问这个变量

RETN 0xC 指令表示从堆栈中弹出 0xC 个字节的数据，并将堆栈指针向上移动相应的字节数。如果没有指定操作数，则默认情况下弹出 4 个字节的返回地址。


# 寄存器
EAX 是 x86 CPU 中的一个 32 位通用寄存器，它可以用于存储数据或指向内存地址，还可以用于进行算术和逻辑运算，作为函数调用的返回值寄存器等。通常用于存储函数的返回值。在函数执行完成后，返回值将存储在 EAX 寄存器中，并通过 RET 指令返回给调用方。

ECX 是 x86 CPU 中的一个 32 位通用寄存器，与 EAX 寄存器类似，它可以用于存储数据或指向内存地址，还可以用于进行算术和逻辑运算。通常被用于循环计数器。在一些情况下，ECX 可以用于存储需要频繁使用的数据，以便快速访问。在 Windows 操作系统中，ECX 可以用于存储函数调用的参数。

EDX 是 x86 CPU 中的一个 32 位通用寄存器，它和 EAX 和 ECX 寄存器一样，在汇编语言中经常被用于进行算术和逻辑运算。但 EDX 还有其他的一些特殊用途。被用作除法运算的余数寄存器。在进行除法运算时，商会存储在 EAX 中，余数会存储在 EDX 中。在 Windows 操作系统中，EDX 寄存器通常用于存储一些操作系统调用的参数，例如文件 I/O 操作的文件句柄和缓冲区长度等。

EBX 是 x86 CPU 中的一个 32 位通用寄存器，它和 EAX、ECX 和 EDX 寄存器一样，在汇编语言中经常被用于进行算术和逻辑运算。但是 EBX 还有其他的一些特殊用途。被用作一些重要的指针寄存器，例如存储地址或指向数据的指针等。在 Windows 操作系统中，EBX 寄存器经常用于存储一些重要的参数或指针，例如传递函数参数或访问数据结构的指针。

ESP 是 x86 架构下的寄存器，代表堆栈指针.在 x86 架构中，堆栈通常从高地址向低地址生长，所以指向压入的当前元素 一定是小于等于栈底

EBP 是 x86 CPU 中的一个 32 位寄存器，通常被用作堆栈帧指针，在函数调用时用于保存栈帧的起始地址。在函数调用时，EBP 被压入栈中，然后被设置为当前栈帧的起始地址，通常指向当前函数的栈帧底部。EBP 还可以用于在调用函数时保存返回地址。返回地址通常保存在当前函数的栈帧顶部，因此可以通过将 EBP 值减去返回地址所在的偏移量来获取返回地址。

ESI 是 x86 CPU 中的一个 32 位寄存器，用于存储源数据的地址。在一些字符串和数组处理操作中，ESI 被广泛用于存储源数据的起始地址和遍历源数据。ESI 通常用于存储指向数组、字符串或其他连续数据结构的指针。

EDI 类似于ESI

EIP 是所有x86CPU中都存在的寄存器，代表指令指针.指令指针是一个特殊的寄存器，用于存储 CPU 执行下一条指令的地址。还可以用于其他用途 实现分支跳转和条件跳转等控制结构，以及实现异常处理和中断处理等机制。在实际编程中，程序员通常使用汇编语言或编译器生成的机器码来直接修改 EIP 寄存器的值，以实现跳转和分支等操作。


## EFL 
>   是x86架构中的标志寄存器，包含了当前程序运行状态的标志位信息
1. CF（Carry Flag）进位标志：在执行加减法操作时，如果最高位（bit 31）进位或借位，CF标志会被设置为1，否则为0。
1. PF（Parity Flag）奇偶标志：该标志用于表示指令结果的二进制位数中1的个数是否为偶数。如果是偶数则PF标志为1，否则为0。
1. AF（Auxiliary Carry Flag）辅助进位标志：在执行加减法操作时，如果第3位进位或借位，AF标志会被设置为1，否则为0。
1. ZF（Zero Flag）零标志：如果指令执行结果为0，ZF标志被设置为1，否则为0。
1. SF（Sign Flag）符号标志：如果指令执行结果为负数，SF标志被设置为1，否则为0。
1. OF（Overflow Flag）溢出标志：在执行加减法操作时，如果结果溢出，则OF标志会被设置为1，否则为0。
1. DF（Direction Flag）方向标志：该标志用于控制字符串操作的方向，如果DF标志被设置为1，字符串操作将从高地址向低地址进行，否则从低地址向高地址进行。
1. IF（Interrupt Flag）中断标志：该标志用于控制中断的响应，如果IF标志被设置为1，CPU可以响应中断请求，否则禁止中断响应。
1. TF（Trap Flag）陷阱标志：该标志用于单步执行调试程序，如果TF标志被设置为1，CPU执行每一条指令后都会触发一次中断，以便调试程序检查执行结果。
1. RF（Resume Flag）恢复标志：该标志用于控制中断的恢复，如果RF标志被设置为1，CPU会忽略中断请求，否则会响应中断请求。
1. VM（虚拟模式标志位，Virtual-8086 Mode Flag）：用于控制CPU是否进入虚拟8086模式。当VM=0时，CPU处于保护模式下；当VM=1时，CPU进入虚拟8086模式，可以运行MS-DOS等16位应用程序。
1. AC（辅助进位标志位，Auxiliary Carry Flag）：用于协助处理二进制运算中的进位问题。当两个4位二进制数相加时，如果第4位有进位，则AC=1，否则AC=0。
1. ID（CPU识别标志位，Identification Flag）：用于区分CPU支持的指令集。当ID=1时，表示CPU支持CPUID指令，可以查询CPU的基本信息。
> 寄存器EFL是32位寄存器，其中每个位都代表着不同的标志位
1. 第0位：CF（Carry Flag），进位标志位；
1. 第2位：PF（Parity Flag），奇偶标志位；
1. 第4位：AF（Adjust Flag），辅助进位标志位；
1. 第6位：ZF（Zero Flag），零标志位；
1. 第7位：SF（Sign Flag），符号标志位；
1. 第8位：TF（Trap Flag），单步标志位；
1. 第9位：IF（Interrupt Flag），中断允许标志位；
1. 第10位：DF（Direction Flag），方向标志位；
1. 第11位：OF（Overflow Flag），溢出标志位
- 除了以上标志位之外，EFL寄存器还有一些保留位和系统位，其中保留位是不使用的，系统位用于处理器内部操作。这些保留位和系统位在不同的CPU架构中可能会有所不同。








##  调试寄存器
调试寄存器是一组专门用于调试的CPU寄存器，通常被称为“调试寄存器”、“调试寄存器组”或“D寄存器组”。调试寄存器允许程序员在程序执行期间监视和调试程序，以及在需要时强制暂停程序的执行。常见的调试寄存器包括以下几种：

- DR0~DR3：数据断点寄存器，用于设置数据访问断点。每个数据断点寄存器可以设置一个断点地址，当访问该地址时，程序会停止执行。

- DR6：调试寄存器状态寄存器，用于指示触发了哪些断点。每个断点都会在DR6中设置一个位，程序员可以通过读取DR6来确定是哪个断点触发了中断。

- DR7：断点控制寄存器，用于控制数据断点和指令断点。可以设置每个数据断点和指令断点是否启用、触发条件和断点类型等属性。

调试寄存器的使用可以提高程序调试的效率和精度，但需要注意的是，不正确地使用调试寄存器可能会导致程序崩溃或产生不可预测的结果。因此，程序员在使用调试寄存器时需要谨慎，并且需要对底层硬件和操作系统有深入的了解。


# 位操作
## 按位与  &
-    0 AND 0 = 0
-    1 AND 0 = 0
-    0 AND 1 = 0
-    1 AND 1 = 1

## 按位或  |
-   0 OR 0 = 0
-   1 OR 0 = 1
-   0 OR 1 = 1
-   1 OR 1 = 1


## 按位异或 ^
同为0，异为1
-     0 XOR 0 = 0
-     1 XOR 0 = 1
-     0 XOR 1 = 1
-     1 XOR 1 = 0

## 非（取反）
-    NOT 1 = 0
-    NOT 0 = 1

# 非与门
一个字节8位的计算
-     11111111 NAND 000000001 = 11111110
-     11111111 NAND 100000000 = 01111111
-     11111111 NAND 111111111 = 00000000
-     00000000 NAND 000000000 = 11111111

# 非或门
一个字节8位的计算
-     11111111 NOR 000000001 = 00000000
-     11111111 NOR 100000000 = 00000000
-     11111111 NOR 111111111 = 00000000
-     00000000 NOR 000000000 = 11111111